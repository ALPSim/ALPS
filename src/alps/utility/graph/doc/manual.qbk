[library BGL Extensions
    [quickbook 1.1]
    [version 1.0]
    [authors [Gamper, Lukas]]
    [copyright 2009 Lukas Gamper]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[section:cg Comparable Graph]

[section:cg_manual Manual]

[section:cg_intro Introduction]

The `nisy` class template is a graph adaptor. It provides functionalities to 

* compare graphs to equality and it defines a ordering relation of a set of graphs.
* find isomorphisms between graphs.
* find the automorphism group of a graph, including the orbit.
* generate a canonical label.
* sort a set of graphs / do binary search in a set of graphs

[endsect]
[section:cg_label Canonical Label]

A canonical label ['C] is a (special) labeling / ordering of the vertices. The canonical labels ['C(G)] and ['C(H)] of two 
graphs ['G ]and ['H] are equivalent if and only if ['G ]and ['H] are isomorphic. The `nisy` class template implements 
the canonical label as the minimal adjacency matrix, which results if all vertices are permuted. To make these matrices 
comparable, they are interpreted as ['n x n]-bit binary number by concatenating all rows.

[h5 Example]

We consider the two graphs
[pre
  A - B       A   B
| / |       | X |
C - D       C - D
]  
and compute the partition containing the ordering of the respective canonical labels. A partiton is 
a set of sets which contains each vertex descriptor exactly once.
[pre
  {( A )( D )( B )( C )}
{( A )( B )( C )( D )}
]
If we order the graphs in the order of the canonical partition, it is easy to see, that they are isomorphic.
[pre
  A   D       A   B
| X |       | X |
B - C       C - D
] 
Now, we can also find the isomorphism between the two graphs:
[pre
  (A->A) (B->C) (C->D) (D->B)
]

[endsect]
[section:cg_automorphism Automorphism Group and Orbit]

The automorphism group induces a special partition on the original graph: the orbit partition. Every cell of the
orbit partition contains one orbit of the automorphisms group of the original graph. 

[h5 Example]

Let us consider the following graph:
[pre
  A - B
| / |
C - D
]
The orbit partition of this graph is 
[pre
  {(A, D), (B, C)}.
]
This means, that you can exchange ['A] and ['D] or ['B] and ['C] 
and the resulting graph is isomorphic to the original one (see [@#bgl_extendions.simpleexample example]).

[endsect]
[section:cg_lazyevaluation Lazy Evaluation and Caching]

The calculation of the canonical label is quite expensive. Therefore, it is 
only done if needed. The canonical label and the orbit are cached. If the original graph is 
mutated, the canonical label and the orbit change. This means, that if the original graph is mutated, the cache of 
the `nisy` needs to be cleared. It can be done with the function `clear_cache`.

[endsect]
[section:cg_coloring Coloring Partition]

If the vertices of the original graph are colored, the coloring needs to be translated into a coloring partition. 
The coloring partition must satisfy the following condition: Two vertices have the same color if and only if they 
are in the same cell of the coloring partition (see [@#bgl_extendions.colorexample example below]).

[endsect]
[section:cg_limits Concepts, Requirements and Limitations]

The `nisy` is public derived from the original graph. It models any concept modelled by the original graph. 
The adaptor only takes a reference to the original graph, not a copy. 

The original graph must model the concepts `VertexListGraph` and `AdjacencyGraph`. 

Only undirected graphs without any edge coloring are supported by the `nisy` graph adaptor.

[endsect]
[section:cg_algo The Algorithm]

The `nisy` determines the canonical label based on the [@http://cs.anu.edu.au/~bdm/nauty/ Nauty]
algorithm described by [@http://cs.anu.edu.au/~bdm/index.html Brendan McKay] in ['B. D. McKay, Practical 
graph isomorphism, 10th. Manitoba Conference on Numerical Mathematics and Computing (Winnipeg, 1980); Congressus Numerantium, 
30 (1981) 45-87].

[endsect]

[endsect]

[section:cg_types Types and Functions]

The functionality supported by `nisy` depends on the underlying `Graph` type. The 
`nisy` class template is public derived form ['Graph], so all types and member functions 
are inherited.

[section:nisy_synopsis Synopsis]

[import nisy.synopsis.hpp]
[nisy_synopsis]

[endsect]
[endsect]

[section:cg_examples Examples]

[section:simpleexample Simple Example]

As a first example, we take two uncolored graphs with 4 vertices and 5 edges. We check if the two graphs are 
isomorphic and if so, we compute the canonical label and the orbit partition of the two graphs. An
orbit partiton contains all 'structural identical' vertices. This means, we can permute the vertices
which lie in the same orbit without changing the canonical label and in this way generate isomorphic graphs.
At the end we generate the explicit isomorphism between the two graphs.

[import nauty.simple.cpp]
[cg_simple]

The output shows that the two graphs are isomorphic. In this simple example, 
we can construct the isomorphism by hand. The vertices with valance two and the vertices with valance 
three must map onto each other.

[pre
  The two graphs are isomorphic.

Canonical partiton and orbit partition of G
0 3 1 2 
{( 1 2 )( 0 3 )}

Canonical partition and orbit partition of H
0 1 2 3 
{( 0 1 )( 2 3 )}

Isomorphism G => H
(0->0) (1->2) (2->3) (3->1) 
]

[endsect]

[section:colorexample Coloring Partition Example]

We look at the same [@#simpleexample example] as avove, but this time with colored vertices:

[import nisy.coloring.cpp]
[coloring_cpp]

The graphs are not isomorphic anymore:

[pre
  The two graphs are not isomorphic.

Canonical partiton and orbit partition of G
{ 0 1 3 2 }
{( 0 )( 1 )( 2 )( 3 )}

Canonical partition and orbit partition of H
{ 0 2 1 3 }
{( 0 )( 1 )( 2 )( 3 )}

Isomorphism G => H
(0->0) (1->2) (2->3) (3->1)
]

[endsect]

[section:generatorexample Generating Nonisomorphic Graphs]

A more advanced example creates all graphs up to a given number of edges and counts the number of 
nonisomorphic graphs with a specific number of edges. 

We first create a small class template to generate all graphs with a given number of vertices.

This class template takes all graphs with one endge less than the requested ones and tries to add vertices
and edges at all possible places. For each new graph, the canonical label is computed.
If the label is not available in the list, the graph is kept, else it is discarded.
The `std::set` allows a binary search over all checked graphs.

[import nisy.generator.hpp]
[graph_generator_hpp]

With the class template above, we only need to loop over all numbers of edges we need. Since the iterators of the
`std::vector` are `RandomAccess` iterators we can get the numbers of graphs by subtracting the first from the one
past the last. We use the `boost::timer` to measure the time needed in seconds.

[import nisy.generator.cpp]
[graph_generator_cpp]

The example returns the following table:

[pre
  \#edges \#graphs time\[s\]
     0       1       0
     1       1       0
     2       1       0
     3       3       0
     4       5       0
     5      12       0
     6      30       0
     7      79       0
     8     227       1
     9     710       3
    10    2323      12
    11    8073      51
    12   29511     232
]

[endsect]

[endsect]

[endsect]
[section:sge Sub Graph Embedding]

[section:sge_manual Manual]

[section:sge_intro Introduction]

The `embedding` algorithm provides functionality to
  
* find all embeddings of a subgraph into a graph.
* find all embeddings of a subgraph into a graph if a vertex of the subgraph and a vertex of the graph are matched.

[endsect]
[section:sge_limits Concepts, Requirements and Limitations]

The subgraph must model the following concepts: `VertexListGraph` and `AdjacencyGraph`. The graph must 
model the concepts `VertexListGraph`, `AdjacencyGraph` and `AdjacendyMatrix`. 

Only undirected graphs are supported. Any coloring is ignored.

[endsect]

[endsect]

[section:sge_types Types and Functions]

The used property map must model `LvaluePropertyMap` with the vertex descriptor of the subgraphs as key type
and the vertex descriptor of the graph as value type. The property map ist passed by reference. Each embedding will overwrite
the previous one. For each embedding, the property map contains a mapping for each vertex descriptor of the subgraph to 
a vertex descriptor of the graph.

The returned iterator `embedding_iterator` models the 
[@http://www.sgi.com/tech/stl/ForwardIterator.html `ForwardIterator`] concept with the associated types:

*  `Value type`: Reference to the property map type.
*  `Distance type`: `std::ptrdiff_t`

[section:embedding_synopsis Synopsis]

[import embedding.synopsis.hpp]
[embedding_synopsis]

[endsect]

[endsect]

[section:sge_examples Examples]

[section:latticeexample Generating a square lattice]

This example does not directly depend on the `embedding` algorihm, but the sub graph embedding algorithm requires a 
graph to embedd the subgraphs. In the following examples we need the function below to create a square lattice, to embed the
subgraphs.

[import embedding.lattice.hpp]
[embedding_lattice_hpp]

[endsect]

[section:embedding_counterexample Use the Sub Graph Embedder]

The `embedding` has two functionalities: 

* we can glue two vertices together and find all embeddings of a subgraph into the graph where the glued vertices are fixed
* we can find all embeddings of the subgrahs into the graph, filtered, so that every embedding that uses a specific set of vertex descriptor of the graph appears only once.
  
This example demonstrates both functionalities: We embed a four-vertex ring into a twelve by twelve square lattice.

[import embedding.counter.hpp]
[embedding_counter_hpp]

This example produces the following output:

[pre
  Number of embeddings: 144
Number of embeddings with 0 and 0 glued together: 8
]

A twelve by twelve lattice has 144 plaquettes, so there are 144 possibilitis to embed a four-vertex ring in this lattice.

A square lattice has four adjacent plaquettes. For each plaquette there are two posibilities to embed a four-vertex ring if the vertex 0 is fixed:

[pre
  0 - 1       0 - 2
|   |  and  |   |
2 - 3       1 - 3
]

[endsect]

[section:listexample List all graphs with their Embeddings]

We can ask how many graphs are embeddable in a square lattice and how many embeddings exist for all graphs of a fixed size.
The following example answers this question by generating all graphs with a fixed number of edges and test if they are embeddable into
a square lattice and count the number of embeddings (see the [@#bgl_extendions.embedding_counterexample previous example]).

[import embedding.list.cpp]
[embedding_list_cpp]

The example produces the following table:

[pre
 \#edges \#graphs \#embeddings time\[s\]
     0       0           0       0
     1       1           4       0
     2       1          12       0
     3       2          60       0
     4       4         204       0
     5       6         900       0
     6      14        3676       0
     7      28       16204       0
     8      68       69508       1
     9     156      328900       3
    10     399     1491884      14
    11    1012     7164740      66
    12    2732    34242396     311
]

[endsect]

[endsect]

[endsect]

[section:ack Acknowledgment]

I would like to thank to my supervisor Simon Trebst. This work would not have been possible without his great support.

[endsect]
