<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Chapter 1. BGL Extensions 1.0</title>
<link rel="stylesheet" href="boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.0">
<link rel="home" href="index.html" title="Chapter 1. BGL Extensions 1.0">
<link rel="next" href="bgl_extensions/sge.html" title="Sub Graph Embedding">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="/Users/gamperl/eclipse/boost/boost.png"></td>
<td align="center"><a href="/Users/gamperl/eclipse/boost/index.html">Home</a></td>
<td align="center"><a href="/Users/gamperl/eclipse/boost/libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="/Users/gamperl/eclipse/boost/more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav"><a accesskey="n" href="bgl_extensions/sge.html"><img src="/Users/gamperl/eclipse/boost/doc/html/images/next.png" alt="Next"></a></div>
<div class="chapter" title="Chapter 1. BGL Extensions 1.0">
<div class="titlepage"><div>
<div><h2 class="title">
<a name="bgl_extensions"></a>Chapter 1. BGL Extensions 1.0</h2></div>
<div><div class="author"><h3 class="author">
<span class="firstname">Lukas</span> <span class="surname">Gamper</span>
</h3></div></div>
<div><p class="copyright">Copyright © 2009 Lukas Gamper</p></div>
<div><div class="legalnotice" title="Legal Notice">
<a name="id553705"></a><p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at [@http://www.boost.org/LICENSE_1_0.txt])
      </p>
</div></div>
</div></div>
<div class="toc">
<p><b>Table of Contents</b></p>
<dl>
<dt><span class="section"><a href="index.html#bgl_extensions.cg"> Comparable Graph</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_manual"> Manual</a></span></dt>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_types"> Types and Functions</a></span></dt>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_examples"> Examples</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="bgl_extensions/sge.html"> Sub Graph Embedding</a></span></dt>
<dd><dl>
<dt><span class="section"><a href="bgl_extensions/sge.html#bgl_extensions.sge_manual"> Manual</a></span></dt>
<dt><span class="section"><a href="bgl_extensions/sge.html#bgl_extensions.sge_types"> Types and Functions</a></span></dt>
<dt><span class="section"><a href="bgl_extensions/sge.html#bgl_extensions.sge_examples"> Examples</a></span></dt>
</dl></dd>
<dt><span class="section"><a href="bgl_extensions/ack.html"> Acknowledgment</a></span></dt>
</dl>
</div>
<div class="section" title="Comparable Graph">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="bgl_extensions.cg"></a> Comparable Graph</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_manual"> Manual</a></span></dt>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_types"> Types and Functions</a></span></dt>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_examples"> Examples</a></span></dt>
</dl></div>
<div class="section" title="Manual">
<div class="titlepage"><div><div><h3 class="title">
<a name="bgl_extensions.cg_manual"></a> Manual</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_intro"> Introduction</a></span></dt>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_label"> Canonical Label</a></span></dt>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_automorphism"> Automorphism Group and Orbit</a></span></dt>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_lazyevaluation"> Lazy Evaluation and Caching</a></span></dt>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_coloring"> Coloring Partition</a></span></dt>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_limits"> Concepts, Requirements and Limitations</a></span></dt>
<dt><span class="section"><a href="index.html#bgl_extensions.cg_algo"> The Algorithm</a></span></dt>
</dl></div>
<div class="section" title="Introduction">
<div class="titlepage"><div><div><h4 class="title">
<a name="bgl_extensions.cg_intro"></a> Introduction</h4></div></div></div>
<p>
          The <code class="computeroutput"><span class="identifier">nisy</span></code> class template
          is a graph adaptor. It provides functionalities to
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            compare graphs to equality and it defines a ordering relation of a set
            of graphs.
          </li>
<li class="listitem">
            find isomorphisms between graphs.
          </li>
<li class="listitem">
            find the automorphism group of a graph, including the orbit.
          </li>
<li class="listitem">
            generate a canonical label.
          </li>
<li class="listitem">
            sort a set of graphs / do binary search in a set of graphs
          </li>
</ul></div>
</div>
<div class="section" title="Canonical Label">
<div class="titlepage"><div><div><h4 class="title">
<a name="bgl_extensions.cg_label"></a> Canonical Label</h4></div></div></div>
<p>
          A canonical label <span class="emphasis"><em>C</em></span> is a (special) labeling / ordering
          of the vertices. The canonical labels <span class="emphasis"><em>C(G)</em></span> and <span class="emphasis"><em>C(H)</em></span>
          of two graphs <span class="emphasis"><em>G </em></span>and <span class="emphasis"><em>H</em></span> are equivalent
          if and only if <span class="emphasis"><em>G </em></span>and <span class="emphasis"><em>H</em></span> are isomorphic.
          The <code class="computeroutput"><span class="identifier">nisy</span></code> class template
          implements the canonical label as the minimal adjacency matrix, which results
          if all vertices are permuted. To make these matrices comparable, they are
          interpreted as <span class="emphasis"><em>n x n</em></span>-bit binary number by concatenating
          all rows.
        </p>
<a name="cg_label.example"></a><h6>
<a name="id553835"></a>
          Example
        </h6>
<p>
          We consider the two graphs
        </p>
<pre class="programlisting">A - B       A   B
| / |       | X |
C - D       C - D
</pre>
<p>
          and compute the partition containing the ordering of the respective canonical
          labels. A partiton is a set of sets which contains each vertex descriptor
          exactly once.
        </p>
<pre class="programlisting">{( A )( D )( B )( C )}
{( A )( B )( C )( D )}
</pre>
<p>
          If we order the graphs in the order of the canonical partition, it is easy
          to see, that they are isomorphic.
        </p>
<pre class="programlisting">A   D       A   B
| X |       | X |
B - C       C - D
</pre>
<p>
          Now, we can also find the isomorphism between the two graphs:
        </p>
<pre class="programlisting">(A-&gt;A) (B-&gt;C) (C-&gt;D) (D-&gt;B)
</pre>
</div>
<div class="section" title="Automorphism Group and Orbit">
<div class="titlepage"><div><div><h4 class="title">
<a name="bgl_extensions.cg_automorphism"></a> Automorphism Group and Orbit</h4></div></div></div>
<p>
          The automorphism group induces a special partition on the original graph:
          the orbit partition. Every cell of the orbit partition contains one orbit
          of the automorphisms group of the original graph.
        </p>
<a name="cg_automorphism.example"></a><h6>
<a name="id553904"></a>
          Example
        </h6>
<p>
          Let us consider the following graph:
        </p>
<pre class="programlisting">A - B
| / |
C - D
</pre>
<p>
          The orbit partition of this graph is
        </p>
<pre class="programlisting">{(A, D), (B, C)}.
</pre>
<p>
          This means, that you can exchange <span class="emphasis"><em>A</em></span> and <span class="emphasis"><em>D</em></span>
          or <span class="emphasis"><em>B</em></span> and <span class="emphasis"><em>C</em></span> and the resulting
          graph is isomorphic to the original one (see <a href="#bgl_extendions.simpleexample" target="_top">example</a>).
        </p>
</div>
<div class="section" title="Lazy Evaluation and Caching">
<div class="titlepage"><div><div><h4 class="title">
<a name="bgl_extensions.cg_lazyevaluation"></a> Lazy Evaluation and Caching</h4></div></div></div>
<p>
          The calculation of the canonical label is quite expensive. Therefore, it
          is only done if needed. The canonical label and the orbit are cached. If
          the original graph is mutated, the canonical label and the orbit change.
          This means, that if the original graph is mutated, the cache of the <code class="computeroutput"><span class="identifier">nisy</span></code> needs to be cleared. It can be done
          with the function <code class="computeroutput"><span class="identifier">clear_cache</span></code>.
        </p>
</div>
<div class="section" title="Coloring Partition">
<div class="titlepage"><div><div><h4 class="title">
<a name="bgl_extensions.cg_coloring"></a> Coloring Partition</h4></div></div></div>
<p>
          If the vertices of the original graph are colored, the coloring needs to
          be translated into a coloring partition. The coloring partition must satisfy
          the following condition: Two vertices have the same color if and only if
          they are in the same cell of the coloring partition (see <a href="#bgl_extendions.colorexample" target="_top">example
          below</a>).
        </p>
</div>
<div class="section" title="Concepts, Requirements and Limitations">
<div class="titlepage"><div><div><h4 class="title">
<a name="bgl_extensions.cg_limits"></a> Concepts, Requirements and Limitations</h4></div></div></div>
<p>
          The <code class="computeroutput"><span class="identifier">nisy</span></code> is public derived
          from the original graph. It models any concept modelled by the original
          graph. The adaptor only takes a reference to the original graph, not a
          copy.
        </p>
<p>
          The original graph must model the concepts <code class="computeroutput"><span class="identifier">VertexListGraph</span></code>
          and <code class="computeroutput"><span class="identifier">AdjacencyGraph</span></code>.
        </p>
<p>
          Only undirected graphs without any edge coloring are supported by the
          <code class="computeroutput"><span class="identifier">nisy</span></code> graph adaptor.
        </p>
</div>
<div class="section" title="The Algorithm">
<div class="titlepage"><div><div><h4 class="title">
<a name="bgl_extensions.cg_algo"></a> The Algorithm</h4></div></div></div>
<p>
          The <code class="computeroutput"><span class="identifier">nisy</span></code> determines the
          canonical label based on the <a href="http://cs.anu.edu.au/~bdm/nauty/" target="_top">Nauty</a>
          algorithm described by <a href="http://cs.anu.edu.au/~bdm/index.html" target="_top">Brendan
          McKay</a> in <span class="emphasis"><em>B. D. McKay, Practical graph isomorphism, 10th.
          Manitoba Conference on Numerical Mathematics and Computing (Winnipeg, 1980);
          Congressus Numerantium, 30 (1981) 45-87</em></span>.
        </p>
</div>
</div>
<div class="section" title="Types and Functions">
<div class="titlepage"><div><div><h3 class="title">
<a name="bgl_extensions.cg_types"></a> Types and Functions</h3></div></div></div>
<div class="toc"><dl><dt><span class="section"><a href="index.html#bgl_extensions.nisy_synopsis"> Synopsis</a></span></dt></dl></div>
<p>
        The functionality supported by <code class="computeroutput"><span class="identifier">nisy</span></code>
        depends on the underlying <code class="computeroutput"><span class="identifier">Graph</span></code>
        type. The <code class="computeroutput"><span class="identifier">nisy</span></code> class template
        is public derived form <span class="emphasis"><em>Graph</em></span>, so all types and member
        functions are inherited.
      </p>
<div class="section" title="Synopsis">
<div class="titlepage"><div><div><h4 class="title">
<a name="bgl_extensions.nisy_synopsis"></a> Synopsis</h4></div></div></div>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span>
    <span class="keyword">class</span> <span class="identifier">graph_type</span> 
  <span class="special">,</span> <span class="keyword">class</span> <span class="identifier">vertex_color_type</span> <span class="special">=</span> <span class="keyword">void</span>
  <span class="special">,</span> <span class="keyword">class</span> <span class="identifier">edge_color_type</span> <span class="special">=</span> <span class="keyword">void</span>
<span class="special">&gt;</span> <span class="keyword">class</span> <span class="identifier">nisy</span> <span class="special">{</span>
  <span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">list</span><span class="special">&lt;</span><span class="identifier">vertex_descriptor_type</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">partition_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">partition_type</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">partition_iterator_type</span><span class="special">;</span>
    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="comment">/*implementation-defined*/</span> <span class="identifier">canonical_label_type</span><span class="special">;</span> <span class="comment">// LessThanComparable
</span>    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="comment">/*implementation-defined*/</span> <span class="identifier">canonical_ordering_iterator</span><span class="special">;</span> <span class="comment">// ForwardIterator
</span>    <span class="identifier">nisy</span><span class="special">(</span>
        <span class="identifier">graph_type</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">graph</span>
    <span class="special">);</span> <span class="comment">// only use iif(vertex_color_type == void and edge_color_type == void)
</span>    <span class="keyword">template</span> <span class="special">&lt;</span>
        <span class="keyword">class</span> <span class="identifier">color_property_map_type</span>
    <span class="special">&gt;</span> <span class="identifier">nisy</span><span class="special">(</span>
        <span class="identifier">graph_type</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">graph</span>
      <span class="special">,</span> <span class="identifier">vertex_color_property_map_type</span> <span class="identifier">vertex_property</span>
    <span class="special">);</span> <span class="comment">// only use iif(vertex_color_type != void and edge_color_type == void)
</span>    <span class="keyword">template</span> <span class="special">&lt;</span>
        <span class="keyword">class</span> <span class="identifier">color_property_map_type</span>
    <span class="special">&gt;</span> <span class="identifier">nisy</span><span class="special">(</span>
        <span class="identifier">graph_type</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">graph</span>
      <span class="special">,</span> <span class="identifier">edge_color_property_map_type</span> <span class="identifier">edge_property</span>
    <span class="special">);</span> <span class="comment">// only use iif(vertex_color_type == void and edge_color_type != void)
</span>    <span class="keyword">template</span> <span class="special">&lt;</span>
        <span class="keyword">class</span> <span class="identifier">vertex_color_property_map_type</span>
      <span class="special">,</span> <span class="keyword">class</span> <span class="identifier">edge_color_property_map_type</span>
    <span class="special">&gt;</span> <span class="identifier">nisy</span><span class="special">(</span>
        <span class="identifier">graph_type</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">graph</span>
      <span class="special">,</span> <span class="identifier">vertex_color_property_map_type</span> <span class="identifier">vertex_property</span>
      <span class="special">,</span> <span class="identifier">edge_color_property_map_type</span> <span class="identifier">edge_property</span>
    <span class="special">);</span> <span class="comment">// only use iif(vertex_color_type != void and edge_color_type != void)
</span>    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">nisy</span><span class="special">();</span>
    <span class="keyword">inline</span> <span class="keyword">void</span> <span class="identifier">invalidate</span><span class="special">();</span>
    <span class="keyword">inline</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">canonical_ordering_iterator</span><span class="special">,</span> <span class="identifier">canonical_ordering_iterator</span><span class="special">&gt;</span> <span class="identifier">get_canonical_ordering</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">inline</span> <span class="identifier">canonical_label_type</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">get_canonical_label</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">inline</span> <span class="identifier">partition_type</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">get_orbit_partition</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">graph_type1</span><span class="special">&gt;</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">==(</span><span class="identifier">nisy</span><span class="special">&lt;</span><span class="identifier">graph_type1</span><span class="special">,</span> <span class="identifier">vertex_color_type</span><span class="special">,</span> <span class="identifier">edge_color_type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">T</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
    <span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">graph_type1</span><span class="special">&gt;</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span><span class="special">!=(</span><span class="identifier">nisy</span><span class="special">&lt;</span><span class="identifier">graph_type1</span><span class="special">,</span> <span class="identifier">vertex_color_type</span><span class="special">,</span> <span class="identifier">edge_color_type</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">T</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span>
    <span class="keyword">class</span> <span class="identifier">graph_type1</span>
  <span class="special">,</span> <span class="keyword">class</span> <span class="identifier">graph_type2</span>
  <span class="special">,</span> <span class="keyword">class</span> <span class="identifier">vertex_coloring_type1</span>
  <span class="special">,</span> <span class="keyword">class</span> <span class="identifier">vertex_coloring_type2</span>
  <span class="special">,</span> <span class="keyword">class</span> <span class="identifier">edge_coloring_type1</span>
  <span class="special">,</span> <span class="keyword">class</span> <span class="identifier">edge_coloring_type2</span>
<span class="special">&gt;</span> <span class="keyword">inline</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span>
      <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">graph_traits</span><span class="special">&lt;</span><span class="identifier">graph_type1</span><span class="special">&gt;::</span><span class="identifier">vertex_descriptor</span>
    <span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">graph_traits</span><span class="special">&lt;</span><span class="identifier">graph_type2</span><span class="special">&gt;::</span><span class="identifier">vertex_descriptor</span>
  <span class="special">&gt;</span> <span class="identifier">isomorphism</span><span class="special">(</span>
      <span class="identifier">nisy</span><span class="special">&lt;</span><span class="identifier">graph_type1</span><span class="special">,</span> <span class="identifier">vertex_coloring_type1</span><span class="special">,</span> <span class="identifier">edge_coloring_type1</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">T1</span>
    <span class="special">,</span> <span class="identifier">nisy</span><span class="special">&lt;</span><span class="identifier">graph_type2</span><span class="special">,</span> <span class="identifier">vertex_coloring_type2</span><span class="special">,</span> <span class="identifier">edge_coloring_type2</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">T2</span>
  <span class="special">);</span>  
</pre>
<p>
          </p>
<p>
        </p>
</div>
</div>
<div class="section" title="Examples">
<div class="titlepage"><div><div><h3 class="title">
<a name="bgl_extensions.cg_examples"></a> Examples</h3></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="index.html#bgl_extensions.simpleexample"> Simple Example</a></span></dt>
<dt><span class="section"><a href="index.html#bgl_extensions.colorexample"> Coloring Partition Example</a></span></dt>
<dt><span class="section"><a href="index.html#bgl_extensions.generatorexample"> Generating Nonisomorphic Graphs</a></span></dt>
</dl></div>
<div class="section" title="Simple Example">
<div class="titlepage"><div><div><h4 class="title">
<a name="bgl_extensions.simpleexample"></a> Simple Example</h4></div></div></div>
<p>
          As a first example, we take two uncolored graphs with 4 vertices and 5
          edges. We check if the two graphs are isomorphic and if so, we compute
          the canonical label and the orbit partition of the two graphs. An orbit
          partiton contains all 'structural identical' vertices. This means, we can
          permute the vertices which lie in the same orbit without changing the canonical
          label and in this way generate isomorphic graphs. At the end we generate
          the explicit isomorphism between the two graphs.
        </p>
<p>
          [cg_simple]
        </p>
<p>
          The output shows that the two graphs are isomorphic. In this simple example,
          we can construct the isomorphism by hand. The vertices with valance two
          and the vertices with valance three must map onto each other.
        </p>
<pre class="programlisting">The two graphs are isomorphic.

Canonical partiton and orbit partition of G
0 3 1 2 
{( 1 2 )( 0 3 )}

Canonical partition and orbit partition of H
0 1 2 3 
{( 0 1 )( 2 3 )}

Isomorphism G =&gt; H
(0-&gt;0) (1-&gt;2) (2-&gt;3) (3-&gt;1) 
</pre>
</div>
<div class="section" title="Coloring Partition Example">
<div class="titlepage"><div><div><h4 class="title">
<a name="bgl_extensions.colorexample"></a> Coloring Partition Example</h4></div></div></div>
<p>
          We look at the same <a href="#simpleexample" target="_top">example</a> as avove,
          but this time with colored vertices:
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="comment">// file: coloring.cpp
</span><span class="preprocessor">#include</span> <span class="string">"../src/nisy.hpp"</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">graph</span><span class="special">/</span><span class="identifier">adjacency_list</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">property_map</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>

<span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">adjacency_list</span><span class="special">&lt;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">vecS</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">vecS</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">undirectedS</span>
<span class="special">&gt;</span> <span class="identifier">graph_type</span><span class="special">;</span>

<span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">graph_traits</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;::</span><span class="identifier">vertex_descriptor</span>
  <span class="special">,</span> <span class="keyword">int</span>
<span class="special">&gt;</span> <span class="identifier">map_type</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">associative_property_map</span><span class="special">&lt;</span><span class="identifier">map_type</span><span class="special">&gt;</span> <span class="identifier">property_map_type</span><span class="special">;</span>
<span class="keyword">enum</span> <span class="special">{</span> <span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">,</span> <span class="identifier">C</span><span class="special">,</span> <span class="identifier">D</span><span class="special">,</span> <span class="identifier">N</span> <span class="special">};</span>

<span class="keyword">typedef</span> <span class="identifier">nisy</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;::</span><span class="identifier">cell_type</span> <span class="identifier">cell_type</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">nisy</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;::</span><span class="identifier">partition_type</span> <span class="identifier">partition_type</span><span class="special">;</span>

<span class="comment">// Write a ordering to cout
</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">ordering_iterator</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">dump_ordering</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">ordering_iterator</span><span class="special">,</span> <span class="identifier">ordering_iterator</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">P</span><span class="special">)</span> <span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"{"</span><span class="special">;</span>
  <span class="keyword">for</span> <span class="special">(</span><span class="identifier">ordering_iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">P</span><span class="special">.</span><span class="identifier">first</span><span class="special">;</span> <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">P</span><span class="special">.</span><span class="identifier">second</span><span class="special">;</span> <span class="special">++</span><span class="identifier">it</span><span class="special">)</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" "</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">it</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" }"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>

<span class="comment">// Write a partition to cout
</span><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">partition_type</span><span class="special">&gt;</span> <span class="keyword">void</span> <span class="identifier">dump_partition</span><span class="special">(</span><span class="identifier">partition_type</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">P</span><span class="special">)</span> <span class="special">{</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"{"</span><span class="special">;</span>
  <span class="keyword">typename</span> <span class="identifier">partition_type</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">it1</span><span class="special">;</span>
  <span class="keyword">typename</span> <span class="identifier">partition_type</span><span class="special">::</span><span class="identifier">value_type</span><span class="special">::</span><span class="identifier">const_iterator</span> <span class="identifier">it2</span><span class="special">;</span>
  <span class="keyword">for</span> <span class="special">(</span><span class="identifier">it1</span> <span class="special">=</span> <span class="identifier">P</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span> <span class="identifier">it1</span> <span class="special">!=</span> <span class="identifier">P</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">it1</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"("</span><span class="special">;</span>
    <span class="keyword">for</span> <span class="special">(</span><span class="identifier">it2</span> <span class="special">=</span> <span class="identifier">it1</span><span class="special">-&gt;</span><span class="identifier">begin</span><span class="special">();</span> <span class="identifier">it2</span> <span class="special">!=</span> <span class="identifier">it1</span><span class="special">-&gt;</span><span class="identifier">end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">it2</span><span class="special">)</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" "</span> <span class="special">&lt;&lt;</span> <span class="special">*</span><span class="identifier">it2</span><span class="special">;</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">" )"</span><span class="special">;</span>
  <span class="special">}</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"}"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>

  <span class="comment">// create the original graphs
</span>  <span class="identifier">graph_type</span> <span class="identifier">g</span><span class="special">(</span><span class="identifier">N</span><span class="special">),</span> <span class="identifier">h</span><span class="special">(</span><span class="identifier">N</span><span class="special">);</span>
<span class="comment">/*
  A - B       A   B
  | / |  vs.  | X |
  C - D       C - D
*/</span>  
  <span class="identifier">add_edge</span><span class="special">(</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">,</span> <span class="identifier">g</span><span class="special">);</span>
  <span class="identifier">add_edge</span><span class="special">(</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">C</span><span class="special">,</span> <span class="identifier">g</span><span class="special">);</span>
  <span class="identifier">add_edge</span><span class="special">(</span><span class="identifier">B</span><span class="special">,</span> <span class="identifier">C</span><span class="special">,</span> <span class="identifier">g</span><span class="special">);</span>
  <span class="identifier">add_edge</span><span class="special">(</span><span class="identifier">B</span><span class="special">,</span> <span class="identifier">D</span><span class="special">,</span> <span class="identifier">g</span><span class="special">);</span>
  <span class="identifier">add_edge</span><span class="special">(</span><span class="identifier">C</span><span class="special">,</span> <span class="identifier">D</span><span class="special">,</span> <span class="identifier">g</span><span class="special">);</span>

  <span class="identifier">add_edge</span><span class="special">(</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">C</span><span class="special">,</span> <span class="identifier">h</span><span class="special">);</span>
  <span class="identifier">add_edge</span><span class="special">(</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">D</span><span class="special">,</span> <span class="identifier">h</span><span class="special">);</span>
  <span class="identifier">add_edge</span><span class="special">(</span><span class="identifier">B</span><span class="special">,</span> <span class="identifier">C</span><span class="special">,</span> <span class="identifier">h</span><span class="special">);</span>
  <span class="identifier">add_edge</span><span class="special">(</span><span class="identifier">B</span><span class="special">,</span> <span class="identifier">D</span><span class="special">,</span> <span class="identifier">h</span><span class="special">);</span>
  <span class="identifier">add_edge</span><span class="special">(</span><span class="identifier">C</span><span class="special">,</span> <span class="identifier">D</span><span class="special">,</span> <span class="identifier">h</span><span class="special">);</span>

  <span class="comment">// create coloring
</span>  <span class="identifier">map_type</span> <span class="identifier">map_g</span><span class="special">,</span> <span class="identifier">map_h</span><span class="special">;</span>
  <span class="identifier">property_map_type</span> <span class="identifier">pmap_g</span><span class="special">(</span><span class="identifier">map_g</span><span class="special">),</span> <span class="identifier">pmap_h</span><span class="special">(</span><span class="identifier">map_h</span><span class="special">);</span>
  
  <span class="comment">// create coloring of g
</span>  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">put</span><span class="special">(</span><span class="identifier">pmap_g</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">A</span><span class="special">),</span> <span class="number">0</span><span class="special">);</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">put</span><span class="special">(</span><span class="identifier">pmap_g</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">B</span><span class="special">),</span> <span class="number">0</span><span class="special">);</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">put</span><span class="special">(</span><span class="identifier">pmap_g</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">C</span><span class="special">),</span> <span class="number">1</span><span class="special">);</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">put</span><span class="special">(</span><span class="identifier">pmap_g</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">D</span><span class="special">),</span> <span class="number">1</span><span class="special">);</span>

  <span class="comment">// create coloring of h
</span>  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">put</span><span class="special">(</span><span class="identifier">pmap_h</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">A</span><span class="special">),</span> <span class="number">0</span><span class="special">);</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">put</span><span class="special">(</span><span class="identifier">pmap_h</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">B</span><span class="special">),</span> <span class="number">1</span><span class="special">);</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">put</span><span class="special">(</span><span class="identifier">pmap_h</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">C</span><span class="special">),</span> <span class="number">0</span><span class="special">);</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">put</span><span class="special">(</span><span class="identifier">pmap_h</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;(</span><span class="identifier">D</span><span class="special">),</span> <span class="number">1</span><span class="special">);</span>
  
  <span class="comment">// create comparable adaptors
</span>  <span class="identifier">nisy</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">cg</span><span class="special">(</span><span class="identifier">g</span><span class="special">,</span> <span class="identifier">pmap_g</span><span class="special">),</span> <span class="identifier">ch</span><span class="special">(</span><span class="identifier">h</span><span class="special">,</span> <span class="identifier">pmap_h</span><span class="special">);</span>

  <span class="comment">// check if the graphs g and h are isomorphic
</span>  <span class="keyword">if</span> <span class="special">(</span><span class="identifier">cg</span> <span class="special">==</span> <span class="identifier">ch</span><span class="special">)</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"The two graphs are isomorphic."</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="keyword">else</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"The two graphs are not isomorphic."</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

  <span class="comment">// dump canonical partiton and arbit of g
</span>  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Canonical partiton and orbit partition of G"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="identifier">dump_ordering</span><span class="special">(</span><span class="identifier">cg</span><span class="special">.</span><span class="identifier">get_canonical_ordering</span><span class="special">());</span>
  <span class="identifier">dump_partition</span><span class="special">(</span><span class="identifier">cg</span><span class="special">.</span><span class="identifier">get_orbit_partition</span><span class="special">());</span>
  
  <span class="comment">// dump canonical partition and arbit of h
</span>  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"Canonical partition and orbit partition of H"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="identifier">dump_ordering</span><span class="special">(</span><span class="identifier">ch</span><span class="special">.</span><span class="identifier">get_canonical_ordering</span><span class="special">());</span>
  <span class="identifier">dump_partition</span><span class="special">(</span><span class="identifier">ch</span><span class="special">.</span><span class="identifier">get_orbit_partition</span><span class="special">());</span>

  <span class="comment">// compute the isomprphism between the two grphas
</span>  <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">map</span><span class="special">&lt;</span>
  	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">graph_traits</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;::</span><span class="identifier">vertex_descriptor</span><span class="special">,</span> 
  	<span class="identifier">boost</span><span class="special">::</span><span class="identifier">graph_traits</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;::</span><span class="identifier">vertex_descriptor</span> 
  <span class="special">&gt;</span> <span class="identifier">isomorphism_type</span><span class="special">;</span>
  <span class="identifier">isomorphism_type</span> <span class="identifier">iso</span><span class="special">(</span><span class="identifier">isomorphism</span><span class="special">(</span><span class="identifier">cg</span><span class="special">,</span> <span class="identifier">ch</span><span class="special">));</span>

  <span class="comment">// write the isomprphism to cout
</span>  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span> <span class="special">&lt;&lt;</span> <span class="string">"Isomorphism G =&gt; H"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="keyword">for</span> <span class="special">(</span><span class="identifier">isomorphism_type</span><span class="special">::</span><span class="identifier">iterator</span> <span class="identifier">it</span> <span class="special">=</span> <span class="identifier">iso</span><span class="special">.</span><span class="identifier">begin</span><span class="special">();</span> <span class="identifier">it</span> <span class="special">!=</span> <span class="identifier">iso</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span> <span class="special">++</span><span class="identifier">it</span><span class="special">)</span>
  	<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"("</span> <span class="special">&lt;&lt;</span> <span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">first</span> <span class="special">&lt;&lt;</span> <span class="string">"-&gt;"</span> <span class="special">&lt;&lt;</span> <span class="identifier">it</span><span class="special">-&gt;</span><span class="identifier">second</span> <span class="special">&lt;&lt;</span> <span class="string">") "</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>

  <span class="keyword">return</span> <span class="identifier">EXIT_SUCCESS</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          The graphs are not isomorphic anymore:
        </p>
<pre class="programlisting">The two graphs are not isomorphic.

Canonical partiton and orbit partition of G
{ 0 1 3 2 }
{( 0 )( 1 )( 2 )( 3 )}

Canonical partition and orbit partition of H
{ 0 2 1 3 }
{( 0 )( 1 )( 2 )( 3 )}

Isomorphism G =&gt; H
(0-&gt;0) (1-&gt;2) (2-&gt;3) (3-&gt;1)
</pre>
</div>
<div class="section" title="Generating Nonisomorphic Graphs">
<div class="titlepage"><div><div><h4 class="title">
<a name="bgl_extensions.generatorexample"></a> Generating Nonisomorphic Graphs</h4></div></div></div>
<p>
          A more advanced example creates all graphs up to a given number of edges
          and counts the number of nonisomorphic graphs with a specific number of
          edges.
        </p>
<p>
          We first create a small class template to generate all graphs with a given
          number of vertices.
        </p>
<p>
          This class template takes all graphs with one endge less than the requested
          ones and tries to add vertices and edges at all possible places. For each
          new graph, the canonical label is computed. If the label is not available
          in the list, the graph is kept, else it is discarded. The <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span></code> allows a binary search over all checked
          graphs.
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="comment">// file: nisy.generator.hpp
</span><span class="preprocessor">#ifndef</span> <span class="identifier">NISY_GENERATOR_HPP</span>
<span class="preprocessor">#define</span> <span class="identifier">NISY_GENERATOR_HPP</span>

<span class="preprocessor">#include</span> <span class="string">"../src/nisy.hpp"</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">graph_type</span><span class="special">&gt;</span> <span class="keyword">class</span> <span class="identifier">graph_generator</span> <span class="special">{</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">graph_traits</span><span class="special">&lt;</span>
    <span class="identifier">graph_type</span>
  <span class="special">&gt;::</span><span class="identifier">vertex_iterator</span> <span class="identifier">vertex_iterator</span><span class="special">;</span>  
  <span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Iterator over all graphs with given #edges
</span>  	<span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;::</span><span class="identifier">const_iterator</span> <span class="identifier">iterator</span><span class="special">;</span>
    <span class="comment">// Defaultconstructor
</span>    <span class="identifier">graph_generator</span><span class="special">()</span>
      <span class="special">:</span> <span class="identifier">graphs_</span><span class="special">(</span><span class="number">1</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;(</span><span class="number">1</span><span class="special">,</span> <span class="identifier">graph_type</span><span class="special">()))</span>
    <span class="special">{</span>
      <span class="identifier">add_vertex</span><span class="special">(</span><span class="identifier">graphs_</span><span class="special">[</span><span class="number">0</span><span class="special">][</span><span class="number">0</span><span class="special">]);</span>
    <span class="special">}</span>
    <span class="comment">// generates all graphs with edge_size edges
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">pair</span><span class="special">&lt;</span><span class="identifier">iterator</span><span class="special">,</span> <span class="identifier">iterator</span><span class="special">&gt;</span> <span class="identifier">generate</span><span class="special">(</span>
      <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">edge_size</span>
    <span class="special">)</span> <span class="special">{</span>
      <span class="identifier">graph_type</span> <span class="special">*</span><span class="identifier">graph</span><span class="special">,</span> <span class="identifier">new_graph</span><span class="special">;</span>
      <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">it</span><span class="special">;</span>
      <span class="identifier">vertex_iterator</span> <span class="identifier">it1</span><span class="special">,</span> <span class="identifier">end1</span><span class="special">,</span> <span class="identifier">it2</span><span class="special">,</span> <span class="identifier">end2</span><span class="special">;</span>
      <span class="comment">// construct all grophs with N edges from the Graphs with N-1 edges
</span>      <span class="keyword">while</span> <span class="special">(</span><span class="identifier">graphs_</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;=</span> <span class="identifier">edge_size</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">graphs_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;());</span>
        <span class="identifier">it</span> <span class="special">=</span> <span class="special">(</span><span class="identifier">graphs_</span><span class="special">.</span><span class="identifier">end</span><span class="special">()</span> <span class="special">-</span> <span class="number">2</span><span class="special">)-&gt;</span><span class="identifier">begin</span><span class="special">();</span> 
        <span class="keyword">while</span> <span class="special">((</span><span class="identifier">graph</span><span class="special">=(</span><span class="identifier">it</span><span class="special">==(</span><span class="identifier">graphs_</span><span class="special">.</span><span class="identifier">end</span><span class="special">()-</span><span class="number">2</span><span class="special">)-&gt;</span><span class="identifier">end</span><span class="special">()?</span><span class="identifier">NULL</span><span class="special">:&amp;(*</span><span class="identifier">it</span><span class="special">++)))!=</span><span class="identifier">NULL</span><span class="special">)</span>
          <span class="keyword">for</span> <span class="special">(</span><span class="identifier">tie</span><span class="special">(</span><span class="identifier">it1</span><span class="special">,</span> <span class="identifier">end1</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">vertices</span><span class="special">(*</span><span class="identifier">graph</span><span class="special">);</span> <span class="identifier">it1</span> <span class="special">!=</span> <span class="identifier">end1</span><span class="special">;</span> <span class="special">++</span><span class="identifier">it1</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">new_graph</span> <span class="special">=</span> <span class="identifier">graph_type</span><span class="special">(*</span><span class="identifier">graph</span><span class="special">);</span>
            <span class="identifier">add_edge</span><span class="special">(*</span><span class="identifier">it1</span><span class="special">,</span> <span class="identifier">add_vertex</span><span class="special">(</span><span class="identifier">new_graph</span><span class="special">),</span> <span class="identifier">new_graph</span><span class="special">);</span>
            <span class="identifier">check_graph</span><span class="special">(</span><span class="identifier">new_graph</span><span class="special">);</span>
            <span class="keyword">for</span> <span class="special">(</span><span class="identifier">tie</span><span class="special">(</span><span class="identifier">it2</span><span class="special">,</span> <span class="identifier">end2</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">vertices</span><span class="special">(*</span><span class="identifier">graph</span><span class="special">);</span> <span class="identifier">it2</span> <span class="special">!=</span> <span class="identifier">end2</span><span class="special">;</span> <span class="special">++</span><span class="identifier">it2</span><span class="special">)</span>
              <span class="keyword">if</span> <span class="special">(*</span><span class="identifier">it1</span> <span class="special">&lt;</span> <span class="special">*</span><span class="identifier">it2</span> <span class="special">&amp;&amp;</span> <span class="special">!</span><span class="identifier">edge</span><span class="special">(*</span><span class="identifier">it1</span><span class="special">,</span> <span class="special">*</span><span class="identifier">it2</span><span class="special">,</span> <span class="special">*</span><span class="identifier">graph</span><span class="special">).</span><span class="identifier">second</span><span class="special">)</span> <span class="special">{</span>
                <span class="identifier">new_graph</span> <span class="special">=</span> <span class="identifier">graph_type</span><span class="special">(*</span><span class="identifier">graph</span><span class="special">);</span>
                <span class="identifier">add_edge</span><span class="special">(*</span><span class="identifier">it1</span><span class="special">,</span> <span class="special">*</span><span class="identifier">it2</span><span class="special">,</span> <span class="identifier">new_graph</span><span class="special">);</span>
	            <span class="identifier">check_graph</span><span class="special">(</span><span class="identifier">new_graph</span><span class="special">);</span>
            <span class="special">}</span>
          <span class="special">}</span>
      <span class="special">}</span>
      <span class="keyword">return</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">make_pair</span><span class="special">(</span>
        <span class="identifier">graphs_</span><span class="special">[</span><span class="identifier">edge_size</span><span class="special">].</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">graphs_</span><span class="special">[</span><span class="identifier">edge_size</span><span class="special">].</span><span class="identifier">end</span><span class="special">()</span>
      <span class="special">);</span>
    <span class="special">}</span>
  <span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">check_graph</span><span class="special">(</span><span class="identifier">graph_type</span> <span class="keyword">const</span> <span class="special">&amp;</span> <span class="identifier">graph</span><span class="special">)</span> <span class="special">{</span>
      <span class="comment">// create comparable adapter
</span>      <span class="identifier">nisy</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;</span> <span class="identifier">com_graph</span><span class="special">(</span><span class="identifier">graph</span><span class="special">);</span>
      <span class="comment">// check if the label has alredy been found
</span>      <span class="keyword">if</span> <span class="special">(</span><span class="identifier">labels_</span><span class="special">.</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">make_tuple</span><span class="special">(</span><span class="identifier">com_graph</span><span class="special">.</span><span class="identifier">get_canonical_label</span><span class="special">().</span><span class="identifier">size</span><span class="special">(),</span> <span class="identifier">com_graph</span><span class="special">.</span><span class="identifier">get_canonical_label</span><span class="special">()))</span> <span class="special">==</span> <span class="identifier">labels_</span><span class="special">.</span><span class="identifier">end</span><span class="special">())</span> <span class="special">{</span>
        <span class="identifier">labels_</span><span class="special">.</span><span class="identifier">insert</span><span class="special">(</span><span class="identifier">make_tuple</span><span class="special">(</span><span class="identifier">com_graph</span><span class="special">.</span><span class="identifier">get_canonical_label</span><span class="special">().</span><span class="identifier">size</span><span class="special">(),</span> <span class="identifier">com_graph</span><span class="special">.</span><span class="identifier">get_canonical_label</span><span class="special">()));</span>
        <span class="identifier">graphs_</span><span class="special">.</span><span class="identifier">back</span><span class="special">().</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">graph</span><span class="special">);</span>
      <span class="special">}</span>
    <span class="special">}</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">graphs_</span><span class="special">;</span>
    <span class="comment">// list of all lables already checked.
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">set</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tuple</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">nisy</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;::</span><span class="identifier">canonical_label_type</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">labels_</span><span class="special">;</span>
<span class="special">};</span>

<span class="preprocessor">#endif</span> <span class="comment">// NISY_GENERATOR_HPP
</span></pre>
<p>
          </p>
<p>
        </p>
<p>
          With the class template above, we only need to loop over all numbers of
          edges we need. Since the iterators of the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
          are <code class="computeroutput"><span class="identifier">RandomAccess</span></code> iterators
          we can get the numbers of graphs by subtracting the first from the one
          past the last. We use the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">timer</span></code>
          to measure the time needed in seconds.
        </p>
<p>
          </p>
<p>
            
</p>
<pre class="programlisting"><span class="comment">// file: nisy.generator.cpp
</span><span class="preprocessor">#include</span> <span class="string">"nisy.generator.hpp"</span>

<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iostream</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">iomanip</span><span class="special">&gt;</span>

<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">timer</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">tuple</span><span class="special">/</span><span class="identifier">tuple</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">graph</span><span class="special">/</span><span class="identifier">adjacency_list</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="preprocessor">#define</span> <span class="identifier">MAX_GRAPH_SIZE</span> <span class="number">12</span>
<span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">adjacency_list</span><span class="special">&lt;</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">vecS</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">vecS</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">undirectedS</span>
<span class="special">&gt;</span> <span class="identifier">graph_type</span><span class="special">;</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
  <span class="comment">// construct generator
</span>  <span class="identifier">graph_generator</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;</span> <span class="identifier">generator</span><span class="special">;</span>
  <span class="identifier">graph_generator</span><span class="special">&lt;</span><span class="identifier">graph_type</span><span class="special">&gt;::</span><span class="identifier">iterator</span> <span class="identifier">it</span><span class="special">,</span> <span class="identifier">end</span><span class="special">;</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">timer</span> <span class="identifier">timer</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"#edges #graphs time[s]"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="keyword">for</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="identifier">MAX_GRAPH_SIZE</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// generate the graphs
</span>    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tie</span><span class="special">(</span><span class="identifier">it</span><span class="special">,</span> <span class="identifier">end</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">generator</span><span class="special">.</span><span class="identifier">generate</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>
    <span class="comment">// write the result to cout
</span>    <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">setw</span><span class="special">(</span><span class="number">6</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">i</span> <span class="special">&lt;&lt;</span> <span class="string">" "</span>
              <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">setw</span><span class="special">(</span><span class="number">7</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="special">(</span><span class="identifier">end</span> <span class="special">-</span> <span class="identifier">it</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="string">" "</span> 
              <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">setw</span><span class="special">(</span><span class="number">7</span><span class="special">)</span>
              <span class="special">&lt;&lt;</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span><span class="special">&gt;(</span><span class="identifier">timer</span><span class="special">.</span><span class="identifier">elapsed</span><span class="special">()+.</span><span class="number">5</span><span class="special">)</span> 
              <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="special">}</span>
  <span class="keyword">return</span> <span class="identifier">EXIT_SUCCESS</span><span class="special">;</span>	
<span class="special">}</span>
</pre>
<p>
          </p>
<p>
        </p>
<p>
          The example returns the following table:
        </p>
<pre class="programlisting">#edges #graphs time[s]
     0       1       0
     1       1       0
     2       1       0
     3       3       0
     4       5       0
     5      12       0
     6      30       0
     7      79       0
     8     227       1
     9     710       3
    10    2323      12
    11    8073      51
    12   29511     232
</pre>
</div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"><p><small>Last revised: May 25, 2009 at 14:34:13 GMT</small></p></td>
<td align="right"><div class="copyright-footer"></div></td>
</tr></table>
<hr>
<div class="spirit-nav"><a accesskey="n" href="bgl_extensions/sge.html"><img src="/Users/gamperl/eclipse/boost/doc/html/images/next.png" alt="Next"></a></div>
</body>
</html>
