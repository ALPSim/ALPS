/***************************************************************************
* ALPS/model library
*
* model/sign.h    checks for sign problem
*
* $Id$
*
* Copyright (C) 2003-2003 by Matthias Troyer <troyer@itp.phys.ethz.ch>,
*                            Synge Todo <wistaria@comp-phys.org>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.

* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#ifndef ALPS_MODEL_SIGN_H
#define ALPS_MODEL_SIGN_H

#include <alps/lattice.h>
#include <alps/model/modellibrary.h>
#include <boost/tuple/tuple.hpp>
#include <boost/tuple/tuple_comparison.hpp>
#include <boost/vector_property_map.hpp>
#include <boost/graph/filtered_graph.hpp>

namespace alps {

namespace parity {

BOOST_STATIC_CONSTANT(parity_type, sign_white = -1);
BOOST_STATIC_CONSTANT(parity_type, sign_black = 1);
BOOST_STATIC_CONSTANT(parity_type, sign_undefined = 0);

template<class Graph, class PropertyMap, class BondPropertyMap>
class SignVisitor {
public:
  typedef typename boost::graph_traits<Graph>::edge_descriptor edge_descriptor;
  typedef typename boost::graph_traits<Graph>::vertex_descriptor vertex_descriptor;

  // constructor
  SignVisitor(PropertyMap& map, bool* check, BondPropertyMap bondsign) :
    map_(map), check_(check), bond_sign_(bondsign) { *check_ = false; }

  // callback member functions
  void initialize_vertex(vertex_descriptor s, const Graph&) {
    map_[s]=sign_undefined;
  }
  void start_vertex(vertex_descriptor, const Graph&) {}
  void discover_vertex(vertex_descriptor s, const Graph&) {
    if (!map_[s]) map_[s]=sign_white;
  }
  void examine_edge(edge_descriptor, const Graph&) {}
  void tree_edge(edge_descriptor e, const Graph& g) {
    map_[boost::target(e,g)]=int(map_[boost::source(e,g)]*bond_sign_[e]);
  }
  void back_edge(edge_descriptor e, const Graph& g) { check(e, g); }
  void forward_or_cross_edge(edge_descriptor e, const Graph& g) {
    check(e, g);
  }
  void finish_vertex(vertex_descriptor, const Graph&) {}

protected:
  void check(edge_descriptor e, const Graph& g) {
    if (map_[boost::source(e, g)] == sign_undefined ||
        map_[boost::target(e, g)] == sign_undefined) {
boost::throw_exception(std::runtime_error("unvisited vertex found"));
    }
    if ( bond_sign_[e]*map_[boost::source(e, g)] != map_[boost::target(e, g)])
      *check_ = true;
  }
private:
  PropertyMap map_;
  bool* check_;
  BondPropertyMap bond_sign_;
};

template<class Graph, class PropertyMap, class BondPropertyMap>
SignVisitor<Graph,PropertyMap,BondPropertyMap> make_sign_visitor(const Graph&, PropertyMap& map, bool* check, BondPropertyMap bondsign)
{
  return SignVisitor<Graph,PropertyMap,BondPropertyMap>(map,check,bondsign);
}

template <class G>
class BondMap {
public:
  typedef G graph_type;
  typedef std::map<boost::tuple<int,int,int>,int> map_type;
  BondMap() {}
  BondMap(const map_type& map, const graph_type& graph)
    : site_type_(alps::get_or_default(alps::site_type_t(), graph, 0)),
      bond_type_(alps::get_or_default(alps::bond_type_t(), graph, 0)),          
      map_(&map),
      graph_(&graph)
  {}
            
  template <class E>
  int operator[] (const E& e) {
    return const_cast<map_type&>(*map_)[boost::tie(bond_type_[e], site_type_[boost::source(e,*graph_)], site_type_[boost::target(e,*graph_)])];
}
private:
  typedef typename alps::property_map<alps::site_type_t, graph_type, int>::const_type site_type_map_t;
  typedef typename alps::property_map<alps::bond_type_t, graph_type, int>::const_type bond_type_map_t;

  site_type_map_t site_type_;
  bond_type_map_t bond_type_;
  const map_type* map_;
  const graph_type* graph_;
};
}

template <typename EdgeWeightMap>
struct nonzero_edge_weight {
  nonzero_edge_weight() { }
  nonzero_edge_weight(EdgeWeightMap weight) : m_weight(weight) { }
  template <typename Edge>
  bool operator()(const Edge& e) const {
    return  m_weight[e]!=0;
  }
  mutable EdgeWeightMap m_weight;
};

template <class G, class M>
bool is_frustrated(const G& graph, M bond_map)
{  
  typedef G graph_type;
  boost::filtered_graph<graph_type,nonzero_edge_weight<M> > g(graph,nonzero_edge_weight<M>(bond_map));
  boost::vector_property_map<int> map; // map to store the relative signs of the sublattices
  bool check; // no sign problem
#ifndef ALPS_USE_DFS2
  boost::depth_first_search(g, boost::visitor(parity::make_sign_visitor(g,map, &check, bond_map)));
#else
  boost::depth_first_search_2(g, boost::visitor(parity::make_sign_visitor(g,map, &check, bond_map)));
#endif
  return check; // no sign problem=>not frustrated
}
                                 
template <class I, class G>
bool has_sign_problem(const HamiltonianDescriptor<I>& ham, const G& graph, const std::map<std::string,OperatorDescriptor<I> >& ops, const Parameters& p) {
  typedef G graph_type;

  typename alps::property_map<alps::site_type_t, graph_type, int>::const_type
  site_type(alps::get_or_default(alps::site_type_t(), graph, 0));

  typename alps::property_map<alps::bond_type_t,  graph_type, int>::const_type
  bond_type(alps::get_or_default(alps::bond_type_t(), graph,0));

  // build and check bond matrices for all bond types
  std::map<boost::tuple<int,int,int>,int> bond_sign;
  for (typename boost::graph_traits<graph_type>::edge_iterator
	 it=boost::edges(graph).first; it!=boost::edges(graph).second ; ++it) {
    int btype  = bond_type[*it];
    int stype1 = site_type[boost::source(*it,graph)];
    int stype2 = site_type[boost::target(*it,graph)];
    if (bond_sign[boost::make_tuple(btype,stype1,stype2)]==0) {
      boost::multi_array<double,4> mat = get_matrix(0.,ham.bond_term(btype),ham.basis().site_basis(stype1),
                                        ham.basis().site_basis(stype2),ops,p);
      int dim1 = mat.shape()[1];
      int dim2 = mat.shape()[2];
      int sign=0;
      for (int i1=0;i1<dim1;++i1)
        for (int j1=0;j1<dim2;++j1)
          for (int i2=0;i2<dim1;++i2)
            for (int j2=0;j2<dim2;++j2)
              if (i1!=i2 && j1 !=j2) {
            int this_sign=(mat[i1][j1][i2][j2] < 0. ? -1 : (mat[i1][j1][i2][j2] > 0. ? 1 : 0));
            if (!sign) // the first nonzero matrix element
              sign = this_sign; // is stored
            else if (this_sign && sign!=this_sign) // compare other nonzero matrix elements
              return true; // we might have a sign problem: indefinite sign of matrix elements 
          }
      bond_sign[boost::make_tuple(btype,stype1,stype2)]=sign;
      bond_sign[boost::make_tuple(btype,stype2,stype1)]=sign;
    }
  }

  // determine "parity" of lattice w.r.t. bond signs

  parity::BondMap<graph_type> bond_map(bond_sign,graph);
  return is_frustrated(graph,bond_map);
}


} // namespace alps

#endif // ALPS_MODEL_SIGN_H
