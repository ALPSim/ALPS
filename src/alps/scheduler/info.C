/***************************************************************************
* ALPS++/scheduler library
*
* scheduler/info.C   A class to store parameters
*
* $Id$
*
* Copyright (C) 1994-2003 by Matthias Troyer <troyer@itp.phys.ethz.ch>,
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.

* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#include <alps/scheduler/info.h>
#include <alps/osiris.h>

#include <algorithm>
#include <boost/functional.hpp>

namespace alps {
namespace scheduler {

Info::Info()
  : startt(time(0)),
    stopt(time(0)),
    host(alps::hostname())
{
}

void Info::save(ODump& dump) const
{
  dump << host << int32_t(startt) << int32_t(stopt) << phase;
}

void Info::load(IDump& dump, int version)
{
  dump >> host;
  startt = int32_t(dump);
  stopt = int32_t(dump);
  if (version<200) {
    int32_t reason;
    int32_t thermalized;
    dump >> reason >> thermalized;
    switch(reason) {
      case THERMALIZED:
        phase = "equilibrating";
	break;
      case INTERRUPTED:
      case HALTED:
        phase = "running";
	break;
      default:
        boost::throw_exception(std::logic_error("unknow reason in Info::load"));
    }
  }
  else
    dump >> phase; 
}


// start the run: save start time and current time as last checkpoint
void Info::start(const std::string& p)
{
  startt = stopt = time(0);
  phase = p;
}


// halt the run: save current time as stop time
void Info::halt()
{
  stopt=time(0);
}


// make a checkpoint: store current time as stop time
void Info::checkpoint()
{
  stopt=time(0);
}


ALPS_DUMMY_VOID Info::write_xml(alps::oxstream& xml) const
{
  std::string time1=ctime(&startt);
  time1.erase(time1.size()-1,1);
  
  std::string time2=ctime(&stopt);
  time2.erase(time2.size()-1,1);
  xml << start_tag("EXECUTED");
  if (phase!="")
    xml << attribute("phase",phase);
  xml << start_tag("FROM") << no_linebreak << time1 << end_tag("FROM");
  xml << start_tag("TO") << no_linebreak << time2 << end_tag("TO");
  xml << start_tag("MACHINE") << no_linebreak << start_tag("NAME") << host 
      << end_tag("NAME") << end_tag("MACHINE");
  xml << end_tag("EXECUTED");
  ALPS_RETURN_VOID
}


void TaskInfo::save (ODump& dump) const
{
  if(!empty()) // update checkpoint time if running
    const_cast<TaskInfo&>(*this).rbegin()->checkpoint();
  dump << static_cast<const std::vector<Info>&>(*this);
}


void TaskInfo::load(IDump& dump, int version)
{
  resize(static_cast<int32_t>(dump));
  for (int i=0;i<size();++i)
    operator[](i).load(dump,version);
  if (version<200) {
    std::string host;
    int32_t dummy;
    dump >> host >> dummy;
    if(dummy)
      dump >> dummy;
    int find_thermalized=0;
    for (int i=0; i<size();++i)
      if (at(i).phase=="equlibrating")
        find_thermalized=i;
    for (int i=0;i<find_thermalized;++i)
      at(i).phase="equlibrating";
  }
}


// start the run new: create new info
void TaskInfo::start(const std::string& phase)
{
  push_back(Info());
  rbegin()->start(phase);
}


// halt the run: store times
void TaskInfo::halt()
{
  if(!empty())
    rbegin()->halt();
  else
    boost::throw_exception( std::logic_error("empty TaskInfo in TaskInfo::halt"));
}


void TaskInfo::write_xml(alps::oxstream& xml) const
{
  std::for_each(begin(),end(),boost::bind2nd(boost::mem_fun_ref(&Info::write_xml),xml));
}

} // namespace scheduler
} // namespace alps
