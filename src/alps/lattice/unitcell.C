/***************************************************************************
* ALPS++/lattice library
*
* lattice/unitcell.C     the unit cell of a lattice
*
* $Id$
*
* Copyright (C) 2001-2003 by Matthias Troyer <troyer@itp.phys.ethz.ch>
*                            Synge Todo <wistaria@comp-phys.org>
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.

* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#include <alps/config.h>

#ifndef ALPS_WITHOUT_XML

#include <alps/lattice/unitcell.h>
#include <alps/vectorio.h>

#include <boost/lexical_cast.hpp>

namespace alps {

GraphUnitCell::GraphUnitCell(const XMLTag& intag, std::istream& p)
{
  XMLTag tag(intag);
  bool fixed_nvertices=false;
  uint32_t vertex_number=0;
  name_ = tag.attributes["name"];
  dim_ = tag.attributes["dimension"]=="" ? 0 
    : boost::lexical_cast<uint32_t,std::string>(tag.attributes["dimension"]);
  if (tag.attributes["vertices"]!="") {
      uint32_t nvert=boost::lexical_cast<uint32_t,std::string>(tag.attributes["vertices"]);
      graph_ = graph_type(nvert);
      fixed_nvertices=true;
  }
  
  if (tag.type !=XMLTag::SINGLE)
  while(true) {
    tag=parse_tag(p);
    if(tag.name=="/UNITCELL")
      return;
    else if (tag.name=="VERTEX") {
      coordinate_type coord;
      int t=tag.attributes["type"]=="" ? 0 : boost::lexical_cast<uint32_t,std::string>(tag.attributes["type"]);
      int id=tag.attributes["id"]=="" ? -1 : boost::lexical_cast<int,std::string>(tag.attributes["id"])-1;
      if (id==-1)
        id=vertex_number++;
      if (id>=boost::num_vertices(graph_)) {
        if (fixed_nvertices)
          boost::throw_exception(std::runtime_error("too many vertices"));
        for (int i=boost::num_vertices(graph_);i<=id;++i)
          boost::add_vertex(graph_);
      }

      if (tag.type!=XMLTag::SINGLE) {
      	tag = parse_tag(p);
        if(tag.name=="COORDINATE") {
          if (tag.type!=XMLTag::SINGLE) {
            read_vector(parse_content(p),coord,dimension());
            tag = parse_tag(p);
            if (tag.name!="/COORDINATE")
              boost::throw_exception(std::runtime_error("closing </COORDINATE> tag missing"));
          }
          tag=parse_tag(p);
        }
      	if (tag.name!="/VERTEX")
          boost::throw_exception(std::runtime_error("closing </VERTEX> tag missing"));
      }

      boost::graph_traits<graph_type>::vertex_iterator vit = boost::vertices(graph_).first+id;
      boost::put(vertex_type_t(),graph_,*vit,t);
      boost::put(coordinate_t(),graph_,*vit,coord);
            
    }
    else if (tag.name=="EDGE") {
      uint32_t source=0, target=0;
      offset_type source_offset(dimension()), target_offset(dimension());
      
      bool got_source=false;
      bool got_target=false;
      
      uint32_t t =tag.attributes["type"]=="" ? 0 
        : boost::lexical_cast<uint32_t,std::string>(tag.attributes["type"]);
      
      if (tag.type!=XMLTag::SINGLE) while (true) {
        tag = parse_tag(p);
        if (tag.name=="/EDGE")
          break;
        if (tag.name=="SOURCE") {
          if(got_source)
            boost::throw_exception(std::runtime_error("Got two <SOURCE> tags in <EDGE>"));
          got_source=true;
          source=boost::lexical_cast<uint32_t,std::string>(tag.attributes["vertex"])-1;
          if(tag.attributes["offset"].size())
            read_vector(tag.attributes["offset"],source_offset);
          if (tag.type!=XMLTag::SINGLE) {
            tag = parse_tag(p);
            if (tag.name !="/SOURCE")
               boost::throw_exception(std::runtime_error("</SOURCE> tag missing"));
          }
        }
        else if(tag.name=="TARGET") {
          if(got_target)
            boost::throw_exception(std::runtime_error("Got two <TARGET> tags in <EDGE>"));
          got_target=true;
          target=boost::lexical_cast<uint32_t,std::string>(tag.attributes["vertex"])-1;
          if(tag.attributes["offset"].size())
            read_vector(tag.attributes["offset"],target_offset);
          if (tag.type!=XMLTag::SINGLE)
          {
            tag = parse_tag(p);
            if (tag.name !="/TARGET")
               boost::throw_exception(std::runtime_error("</TARGET> tag missing"));
          }
        }
      }
      if (!got_source || !got_target)
        boost::throw_exception(std::runtime_error("did not get <SOURCE> and <TARGET> in <EDGE>"));

      boost::graph_traits<graph_type>::edge_descriptor edge = boost::add_edge(source,target,graph_).first;
      boost::put(edge_type_t(),graph_,edge,t);
      boost::put(source_offset_t(),graph_,edge,source_offset);
      boost::put(target_offset_t(),graph_,edge,target_offset);
    }
    else
      boost::throw_exception(std::runtime_error("encountered illegal tag <" + tag.name + "> in UNITCELL"));
  }
}

GraphUnitCell::GraphUnitCell() : dim_(0) {}
GraphUnitCell::GraphUnitCell(const EmptyUnitCell& e) : dim_(alps::dimension(e)) {}

const GraphUnitCell& GraphUnitCell::operator=(const EmptyUnitCell& e)
{
  if (dim_==0) dim_=alps::dimension(e);
  return *this;
}

void GraphUnitCell::write_xml(oxstream& xml) const
{
  xml << start_tag("UNITCELL");
  if (name()!="")
    xml << attribute("name", name());
  xml << attribute("dimension", dimension());
  xml << attribute("vertices", num_vertices(graph_));
  
  typedef boost::graph_traits<graph_type>::vertex_iterator vertex_iterator;
  typedef boost::graph_traits<graph_type>::edge_iterator edge_iterator;
  for (vertex_iterator it=boost::vertices(graph_).first;
                       it!=boost::vertices(graph_).second;++it) {
    xml << start_tag("VERTEX") 
        << attribute("id", boost::get(vertex_index_t(),graph_,*it)+1) 
        << attribute("type", boost::get(vertex_type_t(),graph_,*it));
    if (alps::dimension(boost::get(coordinate_t(),graph_,*it)))
      xml << attribute("coordinate", vector_writer(boost::get(coordinate_t(),graph_,*it)));
    xml << end_tag("VERTEX");
  }
  typedef boost::graph_traits<graph_type>::edge_iterator edge_iterator;
  for (edge_iterator it=boost::edges(graph_).first;
                     it!=boost::edges(graph_).second;++it) {
    xml << start_tag("EDGE")
	<< attribute("type", boost::get(edge_type_t(),graph_,*it))
	<< no_linebreak;
    xml << start_tag("SOURCE")
	<< attribute("vertex",boost::source(*it,graph_)+1);
    if (boost::get(source_offset_t(),graph_,*it).size())
      xml << attribute("offset", vector_writer(boost::get(source_offset_t(),graph_,*it)));
    xml << end_tag("SOURCE");
    xml << start_tag("TARGET")
	<< attribute("vertex", boost::target(*it,graph_)+1);
    if (boost::get(target_offset_t(),graph_,*it).size())
      xml << attribute("offset", vector_writer(boost::get(target_offset_t(),graph_,*it)));
    xml << end_tag("TARGET");
    xml << end_tag("EDGE");
  }
  xml << end_tag("UNITCELL");
}

} // end namespace alps

#endif
