/**************************************************************************
* ALPS++/lattice library
*
* lattice/latticegraph.C    the lattice graph class
*
* $Id$
*
* Copyright (C) 2001-2003 by Matthias Troyer <troyer@itp.phys.ethz.ch>
*                            Synge Todo <wistaria@comp-phys.org>
*
* Permission is hereby granted, free of charge, to any person or organization 
* obtaining a copy of the software covered by this license (the "Software") 
* to use, reproduce, display, distribute, execute, and transmit the Software, 
* and to prepare derivative works of the Software, and to permit others
* to do so for non-commerical academic use, all subject to the following:
*
* The copyright notice in the Software and this entire statement, including 
* the above license grant, this restriction and the following disclaimer, 
* must be included in all copies of the Software, in whole or in part, and 
* all derivative works of the Software, unless such copies or derivative 
* works are solely in the form of machine-executable object code generated by 
* a source language processor.

* In any scientific publication based in part or wholly on the Software, the
* use of the Software has to be acknowledged and the publications quoted
* on the web page http://www.alps.org/license/ have to be referenced.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
* DEALINGS IN THE SOFTWARE.
*
**************************************************************************/

#include <alps/lattice/latticegraphdescriptor.h>

#ifndef ALPS_WITHOUT_XML

#include <alps/lattice/latticegraph.h>
#include <alps/lattice/unitcell.h>
#include <alps/lattice/lattice.h>
#include <alps/vectorio.h>

#include <iostream>

#ifndef BOOST_NO_OPERATORS_IN_NAMESPACE
namespace alps {
namespace detail {
#endif
alps::oxstream& operator<< (alps::oxstream& out, const alps::detail::BasicVertexReference& d)
{
  if (d.cell_offset().size())
    out << attribute("cell", vector_writer(d.cell_offset()));
  if (d.offset().size())
    out << attribute("offset",vector_writer(d.offset()));
  out << attribute("vertex",d.vertex());
  return out;
}


alps::oxstream& operator<< (alps::oxstream& out, const alps::detail::VertexReference& d)
{
  out << start_tag("CELL") << static_cast<const alps::detail::BasicVertexReference&>(d) 
      << attribute("type",d.new_type()) << end_tag("CELL");
}


alps::oxstream& operator<< (alps::oxstream& out, const alps::detail::EdgeReference& d)
{
  out << start_tag("EDGE") << attribute("type",d.new_type());
  no_linebreak(out) << start_tag("SOURCE") << d.source();
  no_linebreak(out) << end_tag("SOURCE") << start_tag("TARGET") << d.target();
  no_linebreak(out) << end_tag("TARGET") << end_tag("EDGE");
}

#ifndef BOOST_NO_OPERATORS_IN_NAMESPACE
} // end namespace detail
} // end namespace alps
#endif


namespace alps {

namespace detail {

BasicVertexReference::BasicVertexReference(XMLTag tag)
{
  vertex_=(tag.attributes["vertex"]=="" ? 0 : boost::lexical_cast<int>(tag.attributes["vertex"]));
  if (tag.attributes["cell"]!="")
    read_vector_resize(tag.attributes["cell"],cell_);
  else
    boost::throw_exception(std::runtime_error("cell attribute missing in <" + tag.name + "> element"));
  if (tag.attributes["offset"]!="")
    read_vector_resize(tag.attributes["offset"],offset_);
}


VertexReference::VertexReference(XMLTag tag, std::istream& in)
{  
  if(tag.attributes["type"]=="")
    boost::throw_exception(std::runtime_error("type attribute missing in changed vertex element"));
  new_type_=boost::lexical_cast<int>(tag.attributes["type"]);
  if (tag.type != XMLTag::SINGLE) {
    tag=parse_tag(in);
    if(tag.name!="/VERTEX")
      boost::throw_exception(std::runtime_error("illegal contents in changed vertex element"));
  }
}

EdgeReference::EdgeReference(XMLTag tag, std::istream& in)
{
  if(tag.attributes["type"]=="")
    boost::throw_exception(std::runtime_error("type attribute missing in changed edge"));
  new_type_=boost::lexical_cast<int>(tag.attributes["type"]);
  tag=parse_tag(in);
  if (tag.name!="SOURCE")
    boost::throw_exception(std::runtime_error("<SOURCE> element missing in changed edge"));
  source_ = BasicVertexReference(tag);
  if (tag.type!=XMLTag::SINGLE) {
    tag=parse_tag(in);
    if(tag.name!="/SOURCE")
      boost::throw_exception(std::runtime_error("illegal contents in <SOURCE> element in changed edge"));
  }
  tag=parse_tag(in);
  if (tag.name!="TARGET")
    boost::throw_exception(std::runtime_error("<TARGET> element missing in changed edge"));
  source_ = BasicVertexReference(tag);
  if (tag.type!=XMLTag::SINGLE) {
    tag=parse_tag(in);
    if(tag.name!="/TARGET")
      boost::throw_exception(std::runtime_error("illegal contents in <TARGET> element in changed edge"));
  }
  tag=parse_tag(in);
  if(tag.name!="/EDGE")
    boost::throw_exception(std::runtime_error("illegal contents in changed edge element"));
}

} // end namespace detail

LatticeGraphDescriptor::LatticeGraphDescriptor(const XMLTag& intag, std::istream& p,
                          const LatticeMap& lm, const FiniteLatticeMap& flm, const UnitCellMap& um)
{
  XMLTag tag(intag);

  for (XMLTag::AttributeMap::const_iterator it=tag.attributes.begin();it!=tag.attributes.end();++it)
  {
    if(it->first=="name")
      name_=it->second;
    else
      boost::throw_exception(std::runtime_error("illegal attribute " + it->first + " in <LATTICEGRAPH> element"));
  }      
  if (tag.type ==XMLTag::SINGLE) 
    boost::throw_exception(std::runtime_error("no lattice specified in <LATTICEGRAPH> element"));
  tag=parse_tag(p);
  if (tag.name=="LATTICE") {
    lattice_is_finite_=false;
    lattice_name_=tag.attributes["ref"];
    if(lattice_name_!="") {
      if (tag.type !=XMLTag::SINGLE) {
        tag=parse_tag(p);
        if(tag.name!="/LATTICE")
          boost::throw_exception(std::runtime_error("illegal contents in <LATTICE> reference tag"));
      }
      if(lm.find(lattice_name_)==lm.end())
        boost::throw_exception(std::runtime_error("unknown lattice: " + lattice_name_));
      lattice_ = lm.find(lattice_name_)->second;
    }
    else
      lattice_=LatticeDescriptor(tag,p);
  }
  else if(tag.name=="FINITELATTICE")
 {
    lattice_is_finite_=true;
    lattice_name_=tag.attributes["ref"];
    if(lattice_name_!="") {
      if (tag.type !=XMLTag::SINGLE) {
        tag=parse_tag(p);
        if(tag.name!="/FINITELATTICE")
          boost::throw_exception(std::runtime_error("illegal contents in <LATTICE> reference tag"));
      }
      if(flm.find(lattice_name_)==flm.end())
          boost::throw_exception(std::runtime_error("unknown lattice: " + lattice_name_));
      finitelattice_ = flm.find(lattice_name_)->second;
    }
    else
      finitelattice_=FiniteLatticeDescriptor(tag,p,lm);
    static_cast<base_type&>(*this) = finitelattice_;
  } 
  
  tag=parse_tag(p);
  if (tag.name!="UNITCELL")
    boost::throw_exception(std::runtime_error("<UNITCELL> element missing in <LATTICEGRAPH>"));
    
  unitcell_name_=tag.attributes["ref"];
  if(unitcell_name_!="") {
    if (tag.type !=XMLTag::SINGLE) {
      tag=parse_tag(p);
      if(tag.name!="/UNITCELL")
        boost::throw_exception(std::runtime_error("illegal contents in <UNITCELL> reference tag"));
    }
    if(um.find(unitcell_name_)==um.end())
      boost::throw_exception(std::runtime_error("unknown unit cell: " + unitcell_name_));
    unit_cell_=const_cast<UnitCellMap&>(um)[unitcell_name_];
  }
  else
    unit_cell_=GraphUnitCell(tag,p);

  tag=parse_tag(p);
  if (tag.name=="CHANGED") {
    tag=parse_tag(p); 
    while (tag.name!="/CHANGED") {
      if (tag.name=="VERTEX")
        changed_vertices_.push_back(detail::VertexReference(tag,p));
      else if (tag.name=="EDGE")
        changed_edges_.push_back(detail::EdgeReference(tag,p));
      else
        boost::throw_exception(std::runtime_error("Illegal element: " + tag.name + "in <CHANGED>"));
      tag=parse_tag(p); 
    }
    tag=parse_tag(p);  
  }
  if (tag.name=="DISORDER") {
    tag=parse_tag(p); 
    while (tag.name!="/DISORDER") {
      if (tag.name=="VERTEX") {
        if (tag.attributes["type"]=="")
          disorder_all_vertices_=true;
        else
          disordered_vertices_.push_back(boost::lexical_cast<unsigned int>(tag.attributes["type"]));
        if (tag.type !=XMLTag::SINGLE) {
          tag=parse_tag(p); 
          if (tag.name!="/VERTEX")
            boost::throw_exception(std::runtime_error("Illegal element: " + tag.name + "in <VERTEX>"));
        }
      }
      else if (tag.name=="EDGE"){
        if (tag.attributes["type"]=="")
          disorder_all_edges_=true;
        else
          disordered_edges_.push_back(boost::lexical_cast<unsigned int>(tag.attributes["type"]));
        if (tag.type !=XMLTag::SINGLE) {
          tag=parse_tag(p); 
          if (tag.name!="/EDGE")
            boost::throw_exception(std::runtime_error("Illegal element: " + tag.name + "in <EDGE>"));
        }
      }
      else
        boost::throw_exception(std::runtime_error("Illegal element: " + tag.name + "in <DISORDER>"));
      tag=parse_tag(p); 
    }
    tag=parse_tag(p);  
  }
  if(tag.name!="/LATTICEGRAPH")
    boost::throw_exception(std::runtime_error("illegal element <" + tag.name + "> in LATTICEGRAPH"));
}

void LatticeGraphDescriptor::set_parameters(const Parameters& p)
{
  if(lattice_is_finite_)
    finitelattice_.set_parameters(p);
  static_cast<base_type&>(*this) = finitelattice_;
}

void LatticeGraphDescriptor::write_xml(oxstream& xml) const
{
  xml << start_tag("LATTICEGRAPH");
  if(name()!="")
    xml << attribute("name", name());
  if(lattice_is_finite_) {
    if (lattice_name_=="")
      xml << finitelattice_;
    else
      xml << start_tag("FINITELATTICE") << attribute("ref", lattice_name_) << end_tag("FINITELATTICE");
  }
  else {
    if (lattice_name_=="")
      xml << lattice_;
    else
      xml << start_tag("LATTICE") << attribute("ref", lattice_name_) << end_tag("LATTICE");
  }
  if (unitcell_name_=="")
    xml << unit_cell_;
  else
    xml << start_tag("UNITCELL") << attribute("ref", unitcell_name_) << end_tag("UNITCELL");
  if (!changed_vertices_.empty() || !changed_edges_.empty()) {
    xml << start_tag("CHANGED");
    for (unsigned int i=0;i<changed_vertices_.size();++i)
      xml << changed_vertices_[i];
    for (unsigned int i=0;i<changed_edges_.size();++i)
      xml << changed_edges_[i];
    xml << end_tag("CHANGED");
  }
  if (!disordered_vertices_.empty() || !disordered_edges_.empty() || 
       disorder_all_vertices_ || disorder_all_edges_) {
    xml << start_tag("DISORDER");
    if (disorder_all_vertices_)
      xml << start_tag("VERTEX") << end_tag("VERTEX");
    else
      for (unsigned int i=0;i<disordered_vertices_.size();++i)
        xml << start_tag("VERTEX") << attribute("type",disordered_vertices_[i]) << end_tag("VERTEX");
    if (disorder_all_edges_)
      xml << start_tag("EDGE") << end_tag("EDGE");
    else
      for (unsigned int i=0;i<disordered_edges_.size();++i)
        xml << start_tag("EDGE") << attribute("type",disordered_edges_[i]) << end_tag("EDGE");
    xml << end_tag("DISORDER");
  }

  xml << end_tag("LATTICEGRAPH");
}

} // end namespace alps

#endif
