<html>
<head>
   <title>PALM++ Project: lattice library library.h</title>
</head>
<body>

<h1>
PALM++ Project: lattice library</h1>

<h2>Header file: library.h</h2>

defines a class <tt>Library</tt> to hold a colection of graphs and lattices,
It can be constructed
from the <tt>&lt;LATTICES></tt> element of the 
<A HREF="http://xml.comp-phys.org/schemas/lattice/">lattice XML schema</A> on 
<A HREF="http://xml.comp-phys.org/">http://xml.comp-phys.org/</A>. </li>
<p>
A second template class, <tt>graph_factory</tt> can be used to create
graphs, given a map of input parameters.

<h3>Synopsis</h3>
<blockquote><pre>
namespace lattice {
{

class Library
{
public:
  Library();
  Library(std::istream&amp; is);
  Library(const palmxml::XMLTag&amp; tag, std::istream&amp; is);

  void read_xml(std::istream&amp; is);
  void read_xml(const palmxml::XMLTag&amp; tag, std::istream&amp; is);

  void write_xml(std::ostream&amp;) const;
  
  bool has_graph(const std::string&amp; name) const;
  bool has_lattice(const std::string&amp; name) const;
  
  const coordinate_graph_type&amp; graph(const std::string&amp; name) const;
  const LatticeGraphDescriptor&amp; lattice(const std::string&amp; name) const;
  
  template &lt;class G>
  bool get_graph(G&amp; graph,const std::string&amp; name) const;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Library&amp; l)
std::istream&amp; operator>>(std::istream&amp;, Library&amp; l)

template &lt;class G=coordinate_graph_type>
class graph_factory : public Library
{
public:
  typedef G graph_type;
  graph_factory();
  graph_factory(std::istream&amp; is);
  graph_factory(std::istream&amp; is, const palm::Parameters&amp; parm);
  graph_factory(const palm::Parameters&amp; parm);
  ~graph_factory();

  void make_graph(const palm::Parameters&amp; p);
   graph_type&amp; graph();
  const graph_type&amp; graph();
};

}
<pre></blockquote>

<H3>The <tt>Library</tt> class</H3>
<h4>Constructors</h4>
<blockquote><pre>
Library();
</pre></blockquote>
an empty library of lattices and graphs.
<blockquote><pre>
Library(std::istream&amp; is);
</pre></blockquote>
reads XML input from a <tt>std::istream</tt>, 
expected to contain a <tt>&lt;LATTICES</tt> element, as given by the
<A HREF="http://xml.comp-phys.org/schemas/lattice/">Lattice XML</A> schema on 
<a href="http://xml.comp-phys.org">http://xml.comp-phys.org</A>.

<blockquote><pre>
Library(const palmxml::XMLTag&amp; tag, std::istream&amp; is);
</pre></blockquote>
The start tag <tt>&lt;LATTICES></tt> has already been read and is passed
as a <a href="http://www.comp-phys.org/software/PALM++/xml/xml.html"><tt>palmxml::XMLTag</tt></a>

<h4>Member functions</h4>
<blockquote><pre>
void read_xml(std::istream&amp; is);
void read_xml(const palmxml::XMLTag&amp; tag, std::istream&amp; is);
</pre></blockquote>
are similar to the cinstructors with corresponding signature. Read additional
lattices and graphs.
<blockquote><pre>
void write_xml(std::ostream&amp;) const;
</pre></blockquote>
writes the contents of the <tt>Library</tt> using the 
<A HREF="http://xml.comp-phys.org/schemas/lattice/">Lattice XML</A> schema on 
<a href="http://xml.comp-phys.org">http://xml.comp-phys.org</A>.
<blockquote><pre>
bool has_graph(const std::string&amp; name) const;
</pre></blockquote>
returns true if the <tt>Library</tt> contains a graph with the given name, read
from a <tt>&lt;GRAPH></tt> element.
<blockquote><pre>
bool has_lattice(const std::string&amp; name) const;
</pre></blockquote>
returns true if the <tt>Library</tt> contains a <a href="graphconcepts.html#LatticeGraph">
LatticeGraph</a> with the given name, read
from a <tt>&lt;LATTICEGRAPH></tt> element.
<blockquote><pre>
const coordinate_graph_type&amp; graph(const std::string&amp; name) const;
</pre></blockquote>
returns a reference to the graph with given name. If the graoh does not exist
(<tt>has_graph</tt> returns <tt>false</tt>) a <tt>std::runtime_error</tt>
is thrown.
<blockquote><pre>
const LatticeGraphDescriptor&amp; lattice(const std::string&amp; name) const;
</pre></blockquote>
returns a reference to the <tt> LatticeGraphDescriptor</tt> with given name. If the
lattice graph does not exist (<tt>has_lattice</tt> returns <tt>false</tt>) 
a <tt>std::runtime_error</tt> is thrown.
<blockquote><pre>
template &lt;class G>
bool get_graph(G&amp; graph,const std::string&amp; name) const;
</pre></blockquote>
If there is a graph with the given name it is copied into the <tt>graph</tt> argument
using the <a href="graph.html"><tt>copy_graph</tt></a> function. Otherwise,
the <tt>graph</tt> argument is unchanged and the function returns false.

<h4>Input and output operators</h4>
<blockquote><pre>
std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const Library&amp; l)
</pre></blockquote>
writes the <tt>Library</tt> using the <tt>write_xml</tt> member function.
<blockquote><pre>
std::istream&amp; operator>>(std::istream&amp;, Library&amp; l)
</pre></blockquote>
reads the <tt>Library</tt> using the <tt>read_xml</tt> member function.

<H3>The <tt>graph_factory</tt> template class</H3>
is an extension of <tt>Library</tt> to a graph factory for the graph type
given as template parameter. This graph type has to be a model of
<A HREF="graphconcepts.html#ReflectablePropertyGraph">ReflectablePropertyGraph</A>.
This graph factory is an example of the way a graph can be created from XML input.
<h4>Type members</h4>
<blockquote><pre>
typedef G graph_type;
</pre></blockquote>
The type of graph
<h4>Constructors</h4>
<blockquote><pre>
graph_factory();
</pre></blockquote>
and empty factory.
<blockquote><pre>
graph_factory(std::istream&amp; is);
</pre></blockquote>
initializes the underlying <tt>Library</tt> by reading from the input.
<blockquote><pre>
graph_factory(const palm::Parameters&amp; parm);
graph_factory(std::istream&amp; is, const palm::Parameters&amp; parm);
</pre></blockquote>
initializes the underlying <tt>Library</tt> by reading from the input
and creates the graph specified by the <tt>Parameters</tt> by the
<tt>make_graph</tt> function.
<blockquote><pre>
graph_factory(const palm::Parameters&amp; parm);
</pre></blockquote>
this constructor first checks for a <tt>LATTICE_LIBRARY</tt> parameter
and opens the file given by the parameter. If no such parameter
is defined, it tried to open a file called "lattices.xml".
Then the contents of the file are read into the library, and the graph created
by the <tt>make_graph</tt> function.


<h4>Member functions</h4>
<blockquote><pre>
void make_graph(const palm::Parameters&amp; p);
</pre></blockquote>
makes a graph based on the information in the <tt>palm::Parameters</tt> argument.
The graph is picked in the following way:
<ul>
<li>If the parameter <tt>GRAPH</tt> is set, the graph with the corresponding name
is created.
<li>If the parameter <tt>LATTICE</tt> is set, the <tt>set_parameters</tt> function of the 
<a href="latticegraphdescriptor.html"><tt>LatticeGraphDescriptor</tt></a>
with the same name
is called to set the parameters (extent and boundary condition) of the lattice. Then
the graph is created from the LatticeGraphDescriptor.
</ul>
If both or none of these parameters are set, or there is not a graph or lattice
with the name, a <tt>std::runtime_error</tt> is thrown.
<blockquote><pre>
graph_type&amp; graph();
const graph_type&amp; graph() const;
</pre></blockquote>
return references to the created graph. The functions throws a <tt>std::runtime_error</tt>
if no graph was created.

<ADDRESS>(c) 2000-2003 by 
<A HREF="mailto:troyer@comp-phys.org">Matthias Troyer</A></ADDRESS>
</body>
</html>

</body>
</html>
