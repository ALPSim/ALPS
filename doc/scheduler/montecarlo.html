<html>
<head>
   <title>ALPS Project: scheduler library montecarlo.h</title>
</head>
<body>

<h1>
ALPS Project: scheduler library</h1>

<h2>
Header file <b> montecarlo.h</b></h2>
This header contains <tt>Worker</tt>, the base class for the user simulation object, and <tt>MCRun</tt> the derived
base class for a Monte Carlo simulation.

<h3>Synopsis</h3>
<blockquote>
<pre>namespace alps {
namespace scheduler {

template &lt;class WORKER>
class SimpleMCFactory : public SimpleFactory&lt;WORKER,MCSimulation>
{
public:
  SimpleMCFactory() {}
};

class Worker
{
public:		
  virtual void dostep()=0;
  virtual double work_done() const =0;
  
  virtual void start();
  virtual void halt();

  virtual bool change_parameter(const std::string&amp; name, const alps::StringValue&amp; value);
  
protected:
  typedef boost::lagged_fibonacci607 random_type;
  random_type random;
  double random_real(double a=0., double b=1.,);
  int random_int(int a, int b);
  int random_int(int n);

  alps::Parameters parms;
  
  osiris::ProcessList where;
};

class MCRun : public Worker
{
public:
  MCRun(const osiris::ProcessList&amp; w, const alps::Parameters&amp; p,int node);

  virtual void save(osiris::ODump&amp; dump) const;
  virtual void load(osiris::IDump&amp; dump) const;
  
  virtual void write_xml(const std::string&amp; name, const std::string&amp; dumpname="") const;
  alea::ObservableSet get_measurements() const;

  virtual bool is_thermalized() const=0;
protected:
  alea::ObservableSet measurements;
};

template &lt;class G=lattice::graph_factory&lt;>::graph_type>
class LatticeMCRun : public MCRun
{
public:
  typedef G graph_type;
  typedef typename boost::graph_traits&lt;graph_type>::vertex_iterator vertex_iterator;
  typedef typename boost::graph_traits&lt;graph_type>::edge_iterator edge_iterator;
  typedef typename boost::graph_traits&lt;graph_type>::out_edge_iterator out_edge_iterator;
  typedef typename boost::graph_traits&lt;graph_type>::in_edge_iterator in_edge_iterator;
  typedef typename boost::graph_traits&lt;graph_type>::edge_descriptor edge_descriptor;
  typedef typename boost::graph_traits&lt;graph_type>::vertex_descriptor vertex_descriptor;
  typedef typename graph_traits&lt;graph_type>::vertices_size_type vertices_size_type;
  typedef typename graph_traits&lt;graph_type>::edges_size_type edges_size_type;
  typedef typename graph_traits&lt;graph_type>::degree_size_type degree_size_type;
  typedef typename graph_traits&lt;graph_type>::adjacency_iterator adjacency_iterator;
  
  typedef typename graph_traits&lt;graph_type>::site_iterator site_iterator;
  typedef typename graph_traits&lt;graph_type>::bond_iterator bond_iterator;
  typedef typename graph_traits&lt;graph_type>::neighbor_bond_iterator neighbor_bond_iterator;
  typedef typename graph_traits&lt;graph_type>::bond_descriptor bond_descriptor;
  typedef typename graph_traits&lt;graph_type>::site_descriptor site_descriptor;
  typedef typename graph_traits&lt;graph_type>::sites_size_type sites_size_type;
  typedef typename graph_traits&lt;graph_type>::bonds_size_type bonds_size_type;
  typedef typename graph_traits&lt;graph_type>::neighbors_size_type neighbors_size_type;
  typedef typename graph_traits&lt;graph_type>::neighbor_iterator neighbor_iterator;
  
  LatticeMCRun(const osiris::ProcessList&amp; w,const alps::Parameters&amp; p,int n);
   
  graph_type&amp; graph();
  const graph_type&amp; graph() const;

  sites_size_type num_sites() const;
  bonds_size_type num_bonds() const;
  std::pair&lt;site_iterator,site_iterator> sites() const;
  std::pair&lt;bond_iterator,bond_iterator> bonds() const;
  bond_descriptor bond(bonds_size_type i) const;
  neighbors_size_type num_neighbors (const site_descriptor&amp; v) const;
  std::pair&lt;neighbor_bond_iterator,neighbor_bond_iterator> neighbor_bonds (const site_descriptor&amp; v) const;  
  std::pair&lt;neighbor_iterator,neighbor_iterator> neighbors (const site_descriptor&amp; v) const;
  site_descriptor neighbor (const site_descriptor&amp; v, neighbors_size_type i) const;
  site_descriptor site(sites_size_type i) const;
  
  vertices_size_type num_vertices() const;
  edges_size_type num_edges() const;
  std::pair&lt;vertex_iterator,vertex_iterator> vertices() const;
  std::pair&lt;edge_iterator,edge_iterator> edges() const;
  degree_size_type out_degree (const vertex_descriptor&amp; v) const;
  degree_size_type in_degree (const vertex_descriptor&amp; v) const;
  degree_size_type degree (const vertex_descriptor&amp; v) const;
  out_edge_iterator out_edges (const vertex_descriptor&amp; v) const;
  in_edge_iterator in_edges (const vertex_descriptor&amp; v) const;
  std::pair&lt;adjacency_iterator,adjacency_iterator> adjacent_vertices (const site_descriptor&amp; v) const; 
  vertex_descriptor vertex(vertices_size_type i) const;

  site_descriptor source(const bond_descriptor&amp; b) const;  
  site_descriptor target(const bond_descriptor&amp; b) const;  
  
  bool is_bipartite() const;
  double parity(const site_descriptor&amp; v) const;
  
  int bond_type(const bond_descriptor&amp; b) const;
};

template &lt;class G=graph_factory&lt;>::graph_type>
class LatticeModelMCRun : public LatticeMCRun&lt;G>
{
public:  
  LatticeModelMCRun(const ProcessList&amp; w,const alps::Parameters&amp; p,int n);
  
  const ModelLibrary::OperatorDescriptorMap&amp; simple_operators() const;
  
  HamiltonianDescriptor&lt;short>&amp; model();
  const HamiltonianDescriptor&lt;short>&amp; model() const;
};

}
}
</pre></blockquote>

<h3>The <tt>SimpleMCFactory</tt> class</h3>
is a factory fo Monte Carlo simulations, supporting one type of simulation. The <tt>WORKKER</tt> object passed as template argument is assumed to be derived from <tt>MCRun</tt> below and will be created by the factory.

<h3>The <tt>Worker</tt> and <tt>MCRun</tt> class</h3>

The <tt>Worker</tt> class is the base class for all user simulations, containing the features not specific to Monte Carlo simulations. At the moment the only use is for Monte Carlo simulations through the derived class <tt>MCRun</tt> but further applications will be added in the future. For now we will thus discuss the members of both classes together.
<h4>Member functions</h4>
<blockquote><pre>
MCRun(const osiris::ProcessList&amp; w, const alps::Parameters&amp; p,int node;
</pre></blockquote>
is the constructor of a new Monte Carlo run. 
<P>The argument <tt>w</tt> gives the processor nodes on which the <tt>MCRun</tt> is created, and the argument <tt>node</tt> the index into this list in case of future multi-CPU simulations. The simulation parameters are given in <p>. These three arguments are passed to the <a href="scheduler.html">factory</a> and will just be passed on to the constructor here.
<blockquote><pre>
virtual void dostep()=0;
</pre></blockquote>
does one simulation step. This needs to be <A href="implementing.html">implemented</A> by the user of the library.
<blockquote><pre>
virtual double work_done() const =0;
</pre></blockquote>
returns the fraction of work that is already done for the simulation. A value of one means that the simulation is finished. This also needs to be <A href="implement.html">implemented</A> by the user of the library.
<blockquote><pre>
virtual void start();
</pre></blockquote>
is called at the start of the simulation and can be overriden to do some initial work.
<blockquote><pre>
virtual void halt();
</pre></blockquote>
is called at the end of the simulation and can be overriden to do some final work.
<blockquote><pre>
virtual bool change_parameter(const std::string&amp; name, const alps::StringValue&amp; value);
</pre></blockquote>
is called when the user changes the parameter given by <tt>name</tt> to a new <tt>value</tt>. If the change is allowed or irrelevant the function should do the appropriate changes and return <tt>true</tt>, while <tt>false</tt> should be returned if the parameter change is not valid.
<blockquote><pre>
virtual void save(osiris::ODump&amp; dump) const;
</pre></blockquote>
should be overriden to save the user data into a checkpoint. In contrast to previous library versions the base class function <tt>MCRun::save</tt> should no longer be called from the derived user class.
<blockquote><pre>
virtual void load(osiris::IDump&amp; dump);
</pre></blockquote>
should be overrideen to read a Monte Carlo run from a checkpoint, if checkpointing support is desired.
<blockquote><pre>
virtual bool is_thermalized() const=0;
</pre></blockquote>
needs to be overridden to give a criterion for equilibration of the Monte Carlo simulation and to determine when real measurements should start.
<blockquote><pre>
alea::ObservableSet get_measurements() const;
</pre></blockquote>
returns the collected measurements.
<h4>Type members</h4>
<blockquote><pre>
typedef boost::lagged_fibonacci607 random_type;
</pre></blockquote>
is the type of random number generator used.
<blockquote><pre>
double random_real(double a=0., double b=1.);
</pre></blockquote>
</pre></blockquote>
provides floating point random numbers in the range <tt>a</tt> to <tt>b</tt>, inclusive the limiting value <tt>a</tt> but excluding <tt>b</tt>.
<blockquote><pre>
int random_int(int a, int b);
</pre></blockquote>
provides integer random numbers in the range <tt>a</tt> to <tt>b</tt>, inclusive the limiting values <tt>a</tt> and <tt>b</tt>.
<blockquote><pre>
int random_int(int n);
</pre></blockquote>
provides integer random numbers in the range <tt>0</tt> to <tt>n-1</tt>, inclusive the limiting values <tt>0</tt> and <tt>n-1</tt>.
<h4>Data members</h4>
<blockquote><pre>
random_type random;
</pre></blockquote>
is the random number generator
<blockquote><pre>
alea::ObservableSet measurements;
</pre></blockquote>
the collected measurements into which measurements should be stored.
<blockquote><pre>
alps::Parameters parms;</pre></blockquote>
</pre></blockquote>
The simulation parameters.
<blockquote><pre>
osiris::ProcessList where;</pre></blockquote>
</pre></blockquote>
the processes of which the simulation is running. This is empty if the simulation has been loaded for evaluation purposes and no actual simulations will be performed.

<h3>The <tt>LatticeMCRun</tt> class template</h3>
is derived from <tt>MCRun</tt> and contains addicitonally a graph object, storing the lattice for a Monte Carlo simulation on a lattice model. The graph type defaults to the default type of <A href="../lattice/library.html">
lattice::graph_factory</a>.

<blockquote><pre>
typedef G graph_type;
typedef typename boost::graph_traits&lt;graph_type>::vertex_iterator vertex_iterator;
typedef typename boost::graph_traits&lt;graph_type>::edge_iterator edge_iterator;
typedef typename boost::graph_traits&lt;graph_type>::out_edge_iterator out_edge_iterator;
typedef typename boost::graph_traits&lt;graph_type>::in_edge_iterator in_edge_iterator;
typedef typename boost::graph_traits&lt;graph_type>::edge_descriptor edge_descriptor;
typedef typename boost::graph_traits&lt;graph_type>::vertex_descriptor vertex_descriptor;
typedef typename graph_traits&lt;graph_type>::vertices_size_type vertices_size_type;
typedef typename graph_traits&lt;graph_type>::edges_size_type edges_size_type;
typedef typename graph_traits&lt;graph_type>::degree_size_type degree_size_type;
typedef typename graph_traits&lt;graph_type>::adjacency_iterator adjacency_iterator;
  
typedef typename graph_traits&lt;graph_type>::site_iterator site_iterator;
typedef typename graph_traits&lt;graph_type>::bond_iterator bond_iterator;
typedef typename graph_traits&lt;graph_type>::neighbor_bond_iterator neighbor_bond_iterator;
typedef typename graph_traits&lt;graph_type>::bond_descriptor bond_descriptor;
typedef typename graph_traits&lt;graph_type>::site_descriptor site_descriptor;
typedef typename graph_traits&lt;graph_type>::sites_size_type sites_size_type;
typedef typename graph_traits&lt;graph_type>::bonds_size_type bonds_size_type;
typedef typename graph_traits&lt;graph_type>::neighbors_size_type neighbors_size_type;
typedef typename graph_traits&lt;graph_type>::neighbor_iterator neighbor_iterator;
</pre></blockquote>
are useful type definitions obtained from <a href="../lattice/graph_traits.html">graph traits</A>.
<blockquote><pre>
LatticeMCRun(const osiris::ProcessList&amp; w,const alps::Parameters&amp; p,int n);
</pre></blockquote>
The constructor creates the graph from the following input parameters:
<table border="1">
<thead><tr><td><b>Parameter</b></td><td><b>Description</b></td></tr></thead>
<tbody>
<tr><td>LATTICE_LIBRARY</td><td>The path to an XML file containg lattice descriptions. It will be used to initialize a <a href="../lattice/library.html">lattice library</a>. The default is a file called "lattices.xml" in the current working directory.</td></tr>
<tr><td>LATTICE</td><td>The name of a lattice or graph in the lattice library. It will be used to create the graph using a <a href="../lattice/library.html">graph factory</a> from the <a href="../lattice/index.html">lattice library</a>.</td></tr>
<tr><td>GRAPH</td><td>A synonym for LATTICE.</td></tr>
</tbody>
</table>
<blockquote><pre>   
graph_type&amp; graph();
const graph_type&amp; graph() const;
</pre></blockquote>
allow access to the graph on which the Monte Carlo simulation is performed.
<blockquote><pre>   
sites_size_type num_sites() const;
bonds_size_type num_bonds() const;
std::pair&lt;site_iterator,site_iterator> sites() const;
std::pair&lt;bond_iterator,bond_iterator> bonds() const;
bond_descriptor bond(bonds_size_type i) const;
neighbors_size_type num_neighbors (const site_descriptor&amp; v) const;
std::pair&lt;neighbor_bond_iterator,neighbor_bond_iterator> neighbor_bonds (const site_descriptor&amp; v) const;
std::pair&lt;neighbor_iterator,neighbor_iterator> neighbors (const site_descriptor&amp; v) const;
site_descriptor neighbor (const site_descriptor&amp; v, neighbors_size_type i) const;
site_descriptor site(sites_size_type i) const;

vertices_size_type num_vertices() const;
edges_size_type num_edges() const;
std::pair&lt;vertex_iterator,vertex_iterator> vertices() const;
std::pair&lt;edge_iterator,edge_iterator> edges() const;
degree_size_type out_degree (const vertex_descriptor&amp; v) const;
degree_size_type in_degree (const vertex_descriptor&amp; v) const;
degree_size_type degree (const vertex_descriptor&amp; v) const;
out_edge_iterator out_edges (const vertex_descriptor&amp; v) const;
in_edge_iterator in_edges (const vertex_descriptor&amp; v) const;
std::pair&lt;adjacency_iterator,adjacency_iterator> adjacent_vertices (const site_descriptor&amp; v) const; 
vertex_descriptor vertex(vertices_size_type i) const;

site_descriptor source(const bond_descriptor&amp; b) const;
site_descriptor target(const bond_descriptor&amp; b) const;
</pre></blockquote>
are useful short cuts for corresponfing functions of the Boost graph library or renamed functions of the <a href="../lattice/graph_traits.html">lattice</a> library. The functions call the corresponding functions with identical name of the Boost graph library or lattice library which take an additional argument specifying the graph.
<blockquote><pre>   
bool is_bipartite() const;
</pre></blockquote>
returns <tt>true</tt> if the graph is bipartite.
<blockquote><pre>   
double parity(const site_descriptor&amp; v) const;
</pre></blockquote>
for a bipartite graph this function returns either +1 or -1 depending on which sublattice the site is on. On a non-bipartite lattice the behavior is undefined.
<blockquote><pre>   
int bond_type(const bond_descriptor&amp; b) const;
</pre></blockquote>
returns the bond (=egde) type of a bond (=edge), obtained from the <tt>edge_type_t</tt> property of the graph.

<h3>The <tt> LatticeModelMCRun</tt> class</h3>
<blockquote><pre>   
const ModelLibrary::OperatorDescriptorMap&amp; simple_operators() const;
</pre></blockquote>
returns a container of operator descriptions used in the model description.
<blockquote><pre>   
HamiltonianDescriptor&lt;short>&amp; model();
const HamiltonianDescriptor&lt;short>&amp; model() const;
</pre></blockquote>
returns the model description.
<HR>
<ADDRESS>copyright (c) 1994-2003 by <A HREF="mailto:troyer@comp-phys.org">Matthias Troyer</A></ADDRESS>
</body>
</html>

</body>
</html>
