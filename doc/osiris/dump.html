<html>
<head>
   <title>ALPS Project: osiris library dump.h</title>
</head>
<body>

<h1>
ALPS Project: osiris library</h1>

<h2>
Header file <b>dump.h</b></h2>
This header contains the abstract base classes for object serialization.
<h3>The osiris serialization mechanism</h3>
The foundation of the dump mechanism are the two abstract classes 
<tt>ODump</tt> and <tt>IDump</tt> that are used to write a representation of an 
object or to reconstruct an object respectively. The actual classes used (
e.g. <tt>IXDRFileDump</tt> and <tt>OXDRFileDump</tt> are derived from these
abstract base classes.
<BR>
The dump mechanism is similar to
the <tt>std::ostream</tt> and <tt>std::istream</tt> classes of the standard C++ 
library, with a few major differences:
<ol>
<li>There is a one-to-one correspondence between the object and its
representation on a dump. An object can be completely reconstructed
from a dump.</li>
<li>This requires a one-to-one correspondence of the 
<tt>operator&lt;&lt;</tt> used to write an object and the
<tt>operator>></tt> used to reconstruct it. Note that this one-to-one 
correspondence is not given for writing/reading a <tt>std::string</tt>
to a standard I/O stream.</li>
<li>The representation is usually in a binary format, and thus 
formatting does not apply.</li>
</ol>

In this library dumps are used mainly for two purposes:
<ol>
<li>for architecture independent storage in disk files, e.g. for 
checkpoints and binary result files.</li>
<li>to send an object to a remote process in a network 
or on a parallel computer.</li>
</ol>
Other uses are of course possible.
<P>An abstract base class <tt>Dumpable</tt> with two pure virtual functions
<tt>save</tt> and <tt>load</tt> is provided to support polymorphism with
serialization.
<P>Pointers can be serialized <I>after</I> the object being pointed to has 
been serialized. In order to do so, the object address must first be registered
with the <tt>ODump</tt>, and is assigned a unique integer identifier. This identifier
is then written instead of the pointer. When deserializing the new object 
address has again to be registered with the <tt>IDump</tt>, to allow 
conversion of the pointer identifier to the new pointer.
<P>Serialization for your own classes can be provided either by deriving 
them from <tt>Dumpable</tt> and implementing the <tt>save</tt> and 
<tt>load</tt> functions or by providing the appropriate <tt>operator&lt;&lt;</tt>
and <tt>operator>></tt>.
<h3>Synopsis</h3>
<blockquote>
<pre>namespace osiris {
class Dumpable
{
public:
  Dumpable();
  virtual void save(ODump& dump) const = 0;
  virtual void load(IDump&) = 0;
};

class ODump
{
public:
  ODump(uint32_t v=0);
  uint32_t version();

  ODump& operator&lt;&lt;(int64_t x);
  ODump& operator&lt;&lt;(int32_t x);
  ODump& operator&lt;&lt;(int16_t x);
  ODump& operator&lt;&lt;(int8_t x);
  ODump& operator&lt;&lt;(uint64_t x);
  ODump& operator&lt;&lt;(uint32_t x);
  ODump& operator&lt;&lt;(uint16_t x);
  ODump& operator&lt;&lt;(uint8_t x);
  ODump& operator&lt;&lt;(float x);
  ODump& operator&lt;&lt;(double x);
  ODump& operator&lt;&lt;(long double x);
  ODump& operator&lt;&lt;(bool x);
  template &lt;class T> ODump& operator&lt;&lt;(std::complex&lt;T> x);
 
  ODump& operator&lt;&lt;(osiris::Dumpable& dump) const;

  virtual void write_array(std::size_t n, const int64_t* p);
  virtual void write_array(std::size_t n, const int32_t* p);
  virtual void write_array(std::size_t n, const int16_t* p);
  virtual void write_array(std::size_t n, const int8_t* p);
  virtual void write_array(std::size_t n, const uint64_t* p);
  virtual void write_array(std::size_t n, const uint32_t* p);
  virtual void write_array(std::size_t n, const uint16_t* p);
  virtual void write_array(std::size_t n, const uint8_t* p);
  virtual void write_array(std::size_t n, const float* p);
  virtual void write_array(std::size_t n, const double* p);
  virtual void write_array(std::size_t n, const long double* p);
  virtual void write_array(std::size_t n, const bool* p);
  virtual void write_string(std::size_t n, const char* s);

  template &lt;class T> void write_array(std::size_t n, const std::complex&lt;T>* p);

  void registerObjectAddress(void* p);
  void writePointer(void* p);
  
protected:
  virtual void write_simple(int64_t x) ;
  virtual void write_simple(int32_t x) = 0;
  virtual void write_simple(int16_t x);
  virtual void write_simple(int8_t x);
  virtual void write_simple(uint64_t x);
  virtual void write_simple(uint32_t x);
  virtual void write_simple(uint16_t x);
  virtual void write_simple(uint8_t x);
  virtual void write_simple(float x);
  virtual void write_simple(double x) = 0;
  virtual void write_simple(long double x) ;
  virtual void write_simple(bool x);
};

class IDump
{
public:
  IDump(uint32_t v=0);

  uint32_t version();

#if defined(ALPS_LINUX) && defined(__GNUC__)
  IDump& operator>>(char& x);
#endif
  IDump& operator>>(int64_t& x);
  IDump& operator>>(int32_t& x);
  IDump& operator>>(int16_t& x);
  IDump& operator>>(int8_t& x);
  IDump& operator>>(uint64_t& x);
  IDump& operator>>(uint32_t& x);
  IDump& operator>>(uint16_t& x);
  IDump& operator>>(uint8_t& x);
  IDump& operator>>(float& x);
  IDump& operator>>(double& x);
  IDump& operator>>(long double& x);
  IDump& operator>>(bool& x);
  template &lt;class T> IDump& operator>>(std::complex&lt;T>& x);

  IDump& operator>>(Dumpable& x);

  virtual void read_array(std::size_t n, int64_t* p);
  virtual void read_array(std::size_t n, int32_t* p);
  virtual void read_array(std::size_t n, int16_t* p);
  virtual void read_array(std::size_t n, int8_t* p);
  virtual void read_array(std::size_t n, uint64_t* p);
  virtual void read_array(std::size_t n, uint32_t* p);
  virtual void read_array(std::size_t n, uint16_t* p);
  virtual void read_array(std::size_t n, uint8_t* p);
  virtual void read_array(std::size_t n, float* p);
  virtual void read_array(std::size_t n, double* p);
  virtual void read_array(std::size_t n, long double* p);
  virtual void read_array(std::size_t n, bool* p);
  virtual void read_string(std::size_t n, char* s);

  template &lt;class T> void read_array(std::size_t n, std::complex&lt;T>* p);

  operator int8_t();
  operator int16_t();
  operator int32_t();
  operator int64_t();
  operator uint8_t();
  operator uint16_t();
  operator uint32_t();
  operator uint64_t();
  operator float();
  operator double();
  operator long double();
  operator bool();
  template &lt;class T> operator std::complex&lt;T>();

  template &lt;class T> T get();
  
  bool test();

  void registerObjectAddress(void* p);

  void* readPointer();
  
protected:
  virtual void read_simple(char& x);
  virtual void read_simple(int64_t& x) = 0;
  virtual void read_simple(int32_t& x) = 0;
  virtual void read_simple(int16_t& x);
  virtual void read_simple(int8_t& x);
  virtual void read_simple(uint64_t& x);
  virtual void read_simple(uint32_t& x);
  virtual void read_simple(uint16_t& x);
  virtual void read_simple(uint8_t& x);
  virtual void read_simple(float& x);
  virtual void read_simple(double& x) = 0;
  virtual void read_simple(long double& x);
  virtual void read_simple(bool& x);
};

}</pre></blockquote>


<h3>The <tt>Dumpable</tt> class</h3>
is an abstract base class providing the interface for using serialization
with polymorphic objects.
<blockquote><pre>
virtual void save(ODump& dump) const = 0;
</pre></blockquote>
serializes the object into an <tt>ODump</tt>.
<blockquote><pre>
virtual void load(IDump&) = 0;
</pre></blockquote>
deserializes the object from an <tt>IDump</tt>.

<h3>The <tt>ODump</tt> class</h3>
is the abstract base class for serialization.
<h4>Constructor</h4>
<blockquote><pre>
ODump(uint32_t v=0);
</pre></blockquote>
The constructor takes an optional version number that can freely be
defined and used by the library user.
<h4>Information</h4>
<blockquote><pre>
uint32_t version() const;
</pre></blockquote>
returns the version number passed to the constructor. This can be used
e.g. to serialize an object differently for different versions of an 
output file.
<H4>Serializing objects</H4>
Objects are serialized using the <tt>operator&lt;&lt;</tt>.
<blockquote><pre>
ODump& operator&lt;&lt;(int64_t x);
ODump& operator&lt;&lt;(int32_t x);
ODump& operator&lt;&lt;(int16_t x);
ODump& operator&lt;&lt;(int8_t x);
ODump& operator&lt;&lt;(uint64_t x);
ODump& operator&lt;&lt;(uint32_t x);
ODump& operator&lt;&lt;(uint16_t x);
ODump& operator&lt;&lt;(uint8_t x);
ODump& operator&lt;&lt;(float x);
ODump& operator&lt;&lt;(double x);
ODump& operator&lt;&lt;(long double x);
ODump& operator&lt;&lt;(bool x);
</pre></blockquote>
serialize the basic simple data types. On Linux using gcc-2.95 additionally a
version for <tt>char</tt> is needed, since <tt>char</tt> there is distinct 
from <tt>uint8_t</tt> and <tt>int8_t</tt>.
<blockquote><pre>
template &lt;class T> ODump& operator&lt;&lt;(std::complex&lt;T> x);
</pre></blockquote>
serializes complex numbers by serializing their real and imaginary 
parts.
<blockquote><pre>
ODump& operator&lt;&lt;(const osiris::Dumpable& dump);
</pre></blockquote>
serializes objects derived from <tt>Dumpable</tt> by calling their 
<tt>save</tt> function.
<blockquote><pre>
virtual void write_array(std::size_t n, const int64_t* p);
virtual void write_array(std::size_t n, const int32_t* p);
virtual void write_array(std::size_t n, const int16_t* p);
virtual void write_array(std::size_t n, const int8_t* p);
virtual void write_array(std::size_t n, const uint64_t* p);
virtual void write_array(std::size_t n, const uint32_t* p);
virtual void write_array(std::size_t n, const uint16_t* p);
virtual void write_array(std::size_t n, const uint8_t* p);
virtual void write_array(std::size_t n, const float* p);
virtual void write_array(std::size_t n, const double* p);
virtual void write_array(std::size_t n, const long double* p);
virtual void write_array(std::size_t n, const bool* p);
</pre></blockquote>
serialize a C-style array of basic data types with <tt>n</tt> elements. The default version just 
calls the corresponding <tt>operator&lt;&lt;</tt> <tt>n</tt> times. 
On Linux using gcc-2.95 additionally a version for <tt>char</tt> is needed, since 
<tt>char</tt> there is distinct from <tt>uint8_t</tt> and <tt>int8_t</tt>.
<blockquote><pre>
template &lt;class T> void write_array(std::size_t n, const std::complex&lt;T>* p);
</pre></blockquote>
serializes an array of complex numbers by interpreting it as a twice as 
large array of real numbers.
<blockquote><pre>
virtual void write_string(std::size_t n, const char* s);
</pre></blockquote>
serializes a C-style string, optionally performing character translations.
Note that the string need <I>not</I> be null-terminated. The default version 
just calls <tt>operator>>(char&)</tt> 
<tt>n</tt> times.
<H4>Serializing pointers</H4>
<blockquote><pre>
void registerObjectAddress(void* p);
</pre></blockquote>
registers a pointer. Before a pointer to an object can be serialized, 
it needs to be registered with the <tt>ODump</tt>, after the object itself 
has been serialized.
<blockquote><pre>
void writePointer(void* p);
</pre></blockquote>
writes a unique integer identifier of a previously registered pointer
to the <tt>ODump</tt>, allowing for a conversion back to a pointer upon 
deserialization. If the pointer has not been registered a 
<tt>std::runtime_error</tt> is thrown.
<H4>Functions for implementors</H4>
<blockquote><pre>
virtual void write_simple(int64_t x) ;
virtual void write_simple(int32_t x) =0;
virtual void write_simple(int16_t x);
virtual void write_simple(int8_t x);
virtual void write_simple(uint64_t x);
virtual void write_simple(uint32_t x);
virtual void write_simple(uint16_t x);
virtual void write_simple(uint8_t x);
virtual void write_simple(float x);
virtual void write_simple(double x) = 0;
virtual void write_simple(long double x) ;
virtual void write_simple(bool x);
</pre></blockquote>
implement serialization of basic data types. It is recommended that all 
these functions be implemented and optimized versions of 
<tt>write_array</tt> and <tt>write_string</tt> be provided. The minimal requirement is an 
implementation for <tt>int32_t</tt> and for <tt>double</tt>. The default 
versions of the other types call the signed version for unsigned integers, 
the 32-bit version for other integer sizes, and the <tt>double</tt> version 
for other floating point types. On Linux using gcc-2.95 additionally a version for <tt>char</tt> is needed, since 
<tt>char</tt> there is distinct from <tt>uint8_t</tt> and <tt>int8_t</tt>.

<h3>The <tt>IDump</tt> class</h3>
is the abstract base class for deserialization.
<blockquote><pre>
IDump(uint32_t v=0);
</pre></blockquote>
The constructor takes an optional version number that can freely be
defined and used by the library user.
<h4>Information</h4>
<blockquote><pre>
uint32_t version() const;
</pre></blockquote>
returns the version number passed to the constructor. This can be used
e.g. to serialize an object differently for different versions of an 
output file.

<H4>Deserializing objects</H4>
Objects are serialized using the <tt>operator>></tt>.
<blockquote><pre>
IDump& operator>>(int64_t& x);
IDump& operator>>(int32_t& x);
IDump& operator>>(int16_t& x);
IDump& operator>>(int8_t& x);
IDump& operator>>(uint64_t& x);
IDump& operator>>(uint32_t& x);
IDump& operator>>(uint16_t& x);
IDump& operator>>(uint8_t& x);
IDump& operator>>(float& x);
IDump& operator>>(double& x);
IDump& operator>>(long double& x);
IDump& operator>>(bool& x);
</pre></blockquote>
deserialize the basic simple data types. On Linux using gcc-2.95 additionally a
version for <tt>char</tt> is needed, since <tt>char</tt> there is distinct 
from <tt>uint8_t</tt> and <tt>int8_t</tt>.
<blockquote><pre>
template &lt;class T> IDump& operator>>(std::complex&lt;T>& x);
</pre></blockquote>
deserializes complex numbers by deserializing their real and imaginary 
parts.
<blockquote><pre>
IDump& operator>>(osiris::Dumpable& dump) const;
</pre></blockquote>
deserializes objects derived from <tt>Dumpable</tt> by calling their 
<tt>load</tt> function.
<blockquote><pre>
virtual void read_array(std::size_t n, int64_t* p);
virtual void read_array(std::size_t n, int32_t* p);
virtual void read_array(std::size_t n, int16_t* p);
virtual void read_array(std::size_t n, int8_t* p);
virtual void read_array(std::size_t n, uint64_t* p);
virtual void read_array(std::size_t n, uint32_t* p);
virtual void read_array(std::size_t n, uint16_t* p);
virtual void read_array(std::size_t n, uint8_t* p);
virtual void read_array(std::size_t n, float* p);
virtual void read_array(std::size_t n, double* p);
virtual void read_array(std::size_t n, long double* p);
virtual void read_array(std::size_t n, bool* p);
</pre></blockquote>
deserializes a C-style array of basic data types with <tt>n</tt> 
elements. Enough memory must have been allocated before calling this 
function. The default version just 
calls the corresponding <tt>operator>></tt> <tt>n</tt> times. 
On Linux using gcc-2.95 additionally a version for <tt>char</tt> is needed, since 
<tt>char</tt> there is distinct from <tt>uint8_t</tt> and <tt>int8_t</tt>.
serializes a C-style string, optionally performing character translations.
Note that the string need <I>not</I> be null-terminated.
<BR><I>Note to implementors:</I> optimized functions for serializing 
C-style arrays can be provided by overriding these virtual functions.
<blockquote><pre>
template &lt;class T> void read_array(std::size_t n, std::complex&lt;T>* p);
</pre></blockquote>
deserializes an array of complex numbers by interpreting it as a twice as 
large array of real numbers.
<blockquote><pre>
virtual void read_string(std::size_t n, char* s);
</pre></blockquote>
deserialzes a C-style string and places a trailing 0 into the string, if 
it is not present. Enough memory must have been allocated before calling this 
function. The default version just calls <tt>operator>>(char&)</tt> 
<tt>n</tt> times.

<H4>Conversion operators</H4>
<blockquote><pre>
operator int8_t();
operator int16_t();
operator int32_t();
operator int64_t();
operator uint8_t();
operator uint16_t();
operator uint32_t();
operator uint64_t();
operator float();
operator double();
operator long double();
operator bool();
template &lt;class T> operator std::complex&lt;T>();
</pre></blockquote>
use the corresponding <tt>operator>></tt> to read an object of the type from the 
<tt>IDump</tt> and return it.
<blockquote><pre>
template &lt;class T> T get();
</pre></blockquote>
use the corresponding <tt>operator>>(T&)</tt> to read an object of the type from the 
<tt>IDump</tt> and return it.
<blockquote><pre>
bool test();
</pre></blockquote>
same as <tt>operator bool()</tt>.

<H4>Deserializing pointers</H4>
<blockquote><pre>
void registerObjectAddress(void* p);
</pre></blockquote>
registers a pointer. Before a pointer to an object can be deserialized, 
it needs to be registered with the <tt>IDump</tt>, after the object itself 
has been deserialized.
<blockquote><pre>
void readPointer(void* p);
</pre></blockquote>
reads a unique integer identifier of a previously registered pointer
from the <tt>IDump</tt> and converts it to a pointer. If the corresponding 
pointer has not been registered a <tt>std::runtime_error</tt> is thrown.

<H4>Functions for implementors</H4>
<blockquote><pre>
virtual void read_simple(int64_t& x) ;
virtual void read_simple(int32_t& x) =0;
virtual void read_simple(int16_t& x);
virtual void read_simple(int8_t& x);
virtual void read_simple(uint64_t& x);
virtual void read_simple(uint32_t& x);
virtual void read_simple(uint16_t& x);
virtual void read_simple(uint8_t& x);
virtual void read_simple(float& x);
virtual void read_simple(double& x) = 0;
virtual void read_simple(long double& x) ;
virtual void read_simple(bool& x);
</pre></blockquote>
implement deserialization of basic data types. It is recommended that all 
these functions be implemented and optimized versions of 
<tt>read_array</tt> and <tt>read_string</tt>be provided. The minimal requirement is an 
implementation for <tt>int32_t</tt> and for <tt>double</tt>. The default 
versions of the other types call the signed version for unsigned integers, 
the 32-bit version for other integer sizes, and the <tt>double</tt> version 
for other floating point types. On Linux using gcc-2.95 additionally a version for <tt>char</tt> is needed, since 
<tt>char</tt> there is distinct from <tt>uint8_t</tt> and <tt>int8_t</tt>.
<HR>
<ADDRESS>(c) 1994-2002 by <A HREF="mailto:troyer@comp-phys.org">Matthias Troyer</A></ADDRESS>
</body>
</html>

</body>
</html>
